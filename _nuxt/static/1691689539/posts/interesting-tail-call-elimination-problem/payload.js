__NUXT_JSONP__("/posts/interesting-tail-call-elimination-problem", (function(a,b,c,d,e,f,g,h,i,j){f[0]="algorithm";f[1]="recursion";f[2]="functional-programming";return {data:[{post:{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}}],fetch:{},mutations:[["post\u002FsetPost",{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}]]}}(true,"interesting-tail-call-elimination-problem","Góc nhìn khác về tail call elimination","Một bài toán thú vị về tối ưu đệ quy giúp tui có góc nhìn khác về tail call elimination như thế nào.","\u003Cp\u003ETui thì đó giờ hay cày rank trên \u003Ca href=\"https:\u002F\u002Fwww.codewars.com\"\u003ECodewars\u003C\u002Fa\u003E, chủ yếu là vì giao diện của nó ngầu lòi hơn ba mấy web thuật toán chán ngắt khác 😄 Chơi một thời gian thì tui cũng lên được 4 kyu và gặp phải bài toán này \u003Ca href=\"https:\u002F\u002Fwww.codewars.com\u002Fkata\u002F57040e445a726387a1001cf7\"\u003EThe fusc function - Part 2\u003C\u002Fa\u003E. Bài này thú vị ở chỗ, thay vì như thông thường họ chỉ đưa mình đề bài, thì bài này họ còn đưa cho mình một bài khác ví dụ mẫu cho phương pháp mà họ muốn mình dùng. Nói chung là giải xong sẽ học được phương pháp gì đó mới, chỉ tiếc là tui lúc đó đã quyết định gập máy đi ngủ 🙂 Mới đầu năm nay thì tui thử mở ra làm lại, và congrats, não tui đã được thông, giờ tui đi thông ngược lại cho mấy bạn đây.\u003C\u002Fp\u003E\n\u003Cp\u003ETrong bài viết này, tui sẽ đi giải quyết bài toán trên trước, mục tiêu bài toán là đưa từ một hàm đệ quy thành một hàm đệ quy đuôi (tail call elimination), đừng lo, tui sẽ giải thích kĩ hơn những thuật ngữ này ở phía dưới. Sau đó tui sẽ chia sẻ một chút về góc nhìn của tui tại sao phương pháp của bài toán này khá độc đáo so với thực tế. Okay triển thôi nào!\u003C\u002Fp\u003E\n\u003Ch2\u003ENội dung bài toán\u003C\u002Fh2\u003E\n\u003Cp\u003EDành cho những con người chây lười không chịu bấm vào link đọc trước (ừa tui đang nói bạn đó) thì tui sẽ trình bày lại bài toán ở đây luôn, \u003Cdel\u003Echứ không phải vì tui muốn bài mình dài ra đâu nha\u003C\u002Fdel\u003E. Với lại tui cũng sẽ làm rõ một số chỗ mà bài viết gốc không đề cập tới.\u003C\u002Fp\u003E\n\u003Cp\u003ECho hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E được định nghĩa như sau:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\begin{cases}\n\\operatorname{fusc}(0) = 0\\\\\n\\operatorname{fusc}(1) = 1\\\\\n\\operatorname{fusc}(2n) = \\operatorname{fusc}(n)\\\\\n\\operatorname{fusc}(2n + 1) = \\operatorname{fusc}(n) + \\operatorname{fusc}(n + 1)\\\\\n\\end{cases}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EViệc của bạn là hãy viết lại và tối ưu hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E trên. Nhớ rằng \u003Cspan class=\"math inline\"\u003E\\(n\\)\u003C\u002Fspan\u003E sẽ có giá trị rất lớn, cụ thể thì \u003Cspan class=\"math inline\"\u003E\\(n\\)\u003C\u002Fspan\u003E sẽ lớn hơn 1000 bit (đối với Javascript) và 52 bit (đối với PHP), nên là cần lưu ý tới vấn đề stack overflow và timeouts.\u003C\u002Fp\u003E\n\u003Ch2\u003EGợi ý phương pháp\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\nPhần này trong lúc đọc mấy bạn không cần quá hoang mang những thứ như là tại sao phải đưa hai vế về cùng dạng, rồi tại sao phải đặt thêm biến a, b các thứ đâu, cứ đọc đến cuối là mọi thứ sẽ trở nên make sense thôi.\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003ETưởng tượng thay vì đề bài là hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E mà là hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n)\\)\u003C\u002Fspan\u003E (trả về \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FFibonacci_number\"\u003Esố Fibonacci\u003C\u002Fa\u003E thứ \u003Cspan class=\"math inline\"\u003E\\(n\\)\u003C\u002Fspan\u003E), thì lúc này hàm được định nghĩa như sau:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\begin{cases}\n\\operatorname{fib}(0) = 1 & (1)\\\\\n\\operatorname{fib}(1) = 1 & (2)\\\\\n\\operatorname{fib}(n + 2) = \\operatorname{fib}(n) + \\operatorname{fib}(n + 1)\\quad (n \\geq 0) & (3)\n\\end{cases}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENếu dùng trực tiếp định nghĩa trên thì không được tối ưu cho lắm. Dĩ nhiên bạn hoàn toàn có thể dùng quy hoạch động, nhưng làm vậy thì lại tốn thêm bộ nhớ không cần thiết, nên là chúng ta sẽ cố thử tìm đệ quy đuôi (\u003Ca href=\"https:\u002F\u002Fwww.geeksforgeeks.org\u002Ftail-recursion\"\u003Etail recursion\u003C\u002Fa\u003E) cho bài toán này.\u003C\u002Fp\u003E\n\u003Cblockquote\u003ELại là góc nhỏ cho những con lười không chịu bấm vào đọc trước định nghĩa của tail recursion đây, thì tail recursion là loại hàm đệ quy mà việc gọi đệ quy là điều cuối cùng hàm đó thực hiện. Lấy ví dụ:\u003C\u002Fblockquote\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F Đây không là tail recursion vì sau khi gọi đệ quy\n\u002F\u002F fact(n-1) thì hàm phải thực hiện thêm phép nhân\n\u002F\u002F với n nữa mới kết thúc\nfunction fact(n) {\n    if (n === 1)\n        return 1\n    else\n        return n * fact(n-1)\n}\n\n\u002F\u002F Đây là tail recursion vì chỉ cần gọi fact(n-1, acc*n)\n\u002F\u002F xong thì hàm sẽ kết thúc\nfunction fact(n, acc) {\n    if (n === 1)\n        return acc\n    else\n        return fact(n-1, acc*n)\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBạn có thể tự tìm hiểu kĩ hơn tại sao khi đưa về tail recursion thì sẽ tối ưu hơn, nhưng để nói sơ qua thì bình thường khi bạn gọi đệ quy, những giá trị, ô nhớ các thứ ở hiện tại sẽ được đẩy lên call stack, cứ mỗi lần gọi đệ quy lồng nhau thì call stack sẽ càng ngày càng cao lên, bộ nhớ phình to ra, cho đến khi vượt quá call stack size thì chương trình trả về lỗi stack overflow. Tail recursion thì lại khác, vì đệ quy là câu lệnh được thực hiện cuối cùng nên compiler sẽ thoải mái giải phóng stack hiện tại vì nó chắc chắn stack hiện tại không cần dùng nữa, nên dù có gọi đệ quy vô hạn lần thì cũng không lo bị stack overflow.\u003C\u002Fp\u003E\n\u003Cp\u003ETiếp tục nhé, bây giờ để biến \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n)\\)\u003C\u002Fspan\u003E thành tail recursion, ta lấy phương trình \u003Cspan class=\"math inline\"\u003E\\((3)\\)\u003C\u002Fspan\u003E đem biến đổi thử, và chúng ta muốn sau khi biến đổi xong thì vế phải phải có dạng giống na ná vế trái, từ đó ta có thể định nghĩa một hàm phụ \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E nào đó sao cho vế trái và vế phải phụ thuộc vào nhau thông qua \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E, kiểu như \u003Cspan class=\"math inline\"\u003E\\(F(2n) = F(3n-1)\\)\u003C\u002Fspan\u003E chẳng hạn. Rồi vậy ta thử cộng \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+1)\\)\u003C\u002Fspan\u003E vào hai vế xem sao:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\operatorname{fib}(n+1) + \\operatorname{fib}(n+2) = \\operatorname{fib}(n) + 2\\cdot \\operatorname{fib}(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EHai vế khá giống nhau rồi đó, \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+1)\\)\u003C\u002Fspan\u003E (vế trái) tương ứng với \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n)\\)\u003C\u002Fspan\u003E (vế phải) là ổn rồi nè, còn \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+2)\\)\u003C\u002Fspan\u003E (vế trái) tương ứng với \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+1)\\)\u003C\u002Fspan\u003E (vế phải) thì vẫn chưa ổn vì bị khác hệ số, để khắc phục chuyện này thì ta sẽ đưa ra một biến khác, gọi là biến \u003Cspan class=\"math inline\"\u003E\\(b\\)\u003C\u002Fspan\u003E đi. Giờ ta thử cộng \u003Cspan class=\"math inline\"\u003E\\((b-1)\\operatorname{fib}(n+2)\\)\u003C\u002Fspan\u003E vào hai vế xem sao (mục đích cộng như vậy là để \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+2)\\)\u003C\u002Fspan\u003E có hệ số là \u003Cspan class=\"math inline\"\u003E\\(b\\)\u003C\u002Fspan\u003E):\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\operatorname{fib}(n+1) + b\\cdot \\operatorname{fib}(n+2) = b\\cdot \\operatorname{fib}(n) + (b+1)\\cdot \\operatorname{fib}(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETa nhận thấy hệ số của \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n+1)\\)\u003C\u002Fspan\u003E và \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n)\\)\u003C\u002Fspan\u003E chưa giống nhau (bên là \u003Cspan class=\"math inline\"\u003E\\(1\\)\u003C\u002Fspan\u003E, bên là \u003Cspan class=\"math inline\"\u003E\\(b\\)\u003C\u002Fspan\u003E), nên là ta đưa thêm biến \u003Cspan class=\"math inline\"\u003E\\(a\\)\u003C\u002Fspan\u003E vào và làm tương tự, ta được:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[a\\cdot \\operatorname{fib}(n+1) + b\\cdot \\operatorname{fib}(n+2) = b\\cdot \\operatorname{fib}(n) + (a+b)\\cdot \\operatorname{fib}(n + 1)\\tag{4}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETuyệt vời ông mặt trời, hai bên có cùng một dạng rồi đó, bây giờ ta định nghĩa hàm phụ \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E như sau:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a, b, n) = a\\cdot \\operatorname{fib}(n) + b\\cdot \\operatorname{fib}(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETừ đó ta có thể biểu diễn hai vế của \u003Cspan class=\"math inline\"\u003E\\((4)\\)\u003C\u002Fspan\u003E dưới dạng:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a, b, n+1) = F(b, a+b, n) \\tag{*}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENgoài ra dựa vào định nghĩa của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E, ta được:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a, b, 0) = a\\cdot \\operatorname{fib}(0) + b\\cdot \\operatorname{fib}(1) = a + b \\tag{5}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EHơn nữa:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\operatorname{fib}(n) = 1\\cdot \\operatorname{fib}(n) + 0\\cdot \\operatorname{fib}(n+1) = F(1, 0, n) \\tag{6}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETa đã hoàn toàn có đủ nguyên liệu để triển khai thuật toán rồi đó, để ý:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((6)\\)\u003C\u002Fspan\u003E cho ta được định nghĩa tổng quát của \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fib}(n)\\)\u003C\u002Fspan\u003E dựa trên hàm phụ \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((*)\\)\u003C\u002Fspan\u003E cho ta công thức đệ quy của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((5)\\)\u003C\u002Fspan\u003E cho ta base case đệ quy của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EHy vọng tới đây mọi thứ make sense được với bạn, nếu lú thì cũng không sao cứ đọc lại nhé, mấy lần đầu mình đọc cũng lú 🙂 Giờ thì code thôi (2 code dưới này đều là của tác giả bài toán hết nha, không phải của tui):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Edef fib(n):\n\n    def F(a, b, n):\n        if n == 0: return a + b    # see (5) above\n        return F(b, a + b, n - 1)  # see (*) above\n\n    return F(1, 0, n)              # see (6) above\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETới đây là \u003Cspan class=\"math inline\"\u003E\\(QED\\)\u003C\u002Fspan\u003E rồi, nhưng nếu ngôn ngữ bạn dùng không hỗ trợ tối ưu đệ quy đuôi (\u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F310974\u002Fwhat-is-tail-call-optimization\"\u003Etail call optimization\u003C\u002Fa\u003E) thì bạn có thể implement theo dạng khử đệ quy như sau:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-python\"\u003Edef fib(n):\n    a, b = 1, 0                    # see (6) above\n    while n &gt; 0:\n        a, b, n = b, a + b, n - 1  # see (*) above\n    return a + b .                 # see (5) above\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\nĐây là một sức mạnh khác của tail recursion, một khi bạn đã đưa hàm về tail recursion rồi thì việc khử đệ quy là vô cùng đơn giản.\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003ETuyệt dời, làm &ldquo;tương tự&rdquo; với hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E thôi nào 😉. Nếu đọc tới đây mà bạn đã có ý tưởng, hoặc muốn thử sức bản thân thì có thể pause lại. Thật ra theo tui thì một khi đã nắm được ý tưởng của phương pháp này rồi thì cũng không quá khó đâu.\u003C\u002Fp\u003E\n\u003Ch2\u003EGiải quyết bài toán\u003C\u002Fh2\u003E\n\u003Cp\u003ENhắc lại định nghĩa của hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E. Để cho \u003Cdel\u003Egõ đỡ mỏi tay\u003C\u002Fdel\u003E đơn giản thì tui đặt hàm \u003Cspan class=\"math inline\"\u003E\\(\\operatorname{fusc}(n)\\)\u003C\u002Fspan\u003E là hàm \u003Cspan class=\"math inline\"\u003E\\(f(n)\\)\u003C\u002Fspan\u003E luôn nhé:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\begin{cases}\nf(0) = 0 & (1)\\\\\nf(1) = 1 & (2)\\\\\nf(2n) = f(n) & (3)\\\\\nf(2n + 1) = f(n) + f(n + 1) & (4)\\\\\n\\end{cases}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETương tự như ví dụ trên, từ định nghĩa ta sẽ cố gắng tìm phương trình nào đó sao cho hai vế có cùng dạng, rồi từ đó đặt hàm phụ. Lấy \u003Cspan class=\"math inline\"\u003E\\((3)\\)\u003C\u002Fspan\u003E và \u003Cspan class=\"math inline\"\u003E\\((4)\\)\u003C\u002Fspan\u003E cộng lại với nhau thử coi sao:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[f(2n)+f(2n+1)=2f(n) + f(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThấy hai vế cũng na ná giống rồi nè, \u003Cspan class=\"math inline\"\u003E\\(f(2n)\\)\u003C\u002Fspan\u003E tương ứng với \u003Cspan class=\"math inline\"\u003E\\(f(n)\\)\u003C\u002Fspan\u003E và \u003Cspan class=\"math inline\"\u003E\\(f(2n+1)\\)\u003C\u002Fspan\u003E tương ứng với \u003Cspan class=\"math inline\"\u003E\\(f(n+1)\\)\u003C\u002Fspan\u003E. Bây giờ tìm cách cân bằng hệ số thôi. Cụ thể, ta sẽ đưa biến \u003Cspan class=\"math inline\"\u003E\\(b\\)\u003C\u002Fspan\u003E vào phương trình bằng cách cộng \u003Cspan class=\"math inline\"\u003E\\((b-1)f(2n+1)\\)\u003C\u002Fspan\u003E hai vế, ta được:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[f(2n)+bf(2n+1)=(b+1)f(n) + bf(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETương tự, đưa biến \u003Cspan class=\"math inline\"\u003E\\(a\\)\u003C\u002Fspan\u003E vào phương trình:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[af(2n)+bf(2n+1)=(a+b)f(n) + bf(n+1) \\tag{5}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EHai vế đã cùng dạng như mình ao ước rồi đó, giờ định nghĩa hàm phụ \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E thôi:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a, b, n) = af(n) + bf(n+1)\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETừ đó ta biểu diễn \u003Cspan class=\"math inline\"\u003E\\((5)\\)\u003C\u002Fspan\u003E theo \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E như sau:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a,b,2n) = F(a+b,b,n) \\tag{*}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENgoài ra từ định nghĩa của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E suy ra được:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a,b,0) = af(0) + bf(1) = b \\tag{6.1}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EVà:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[F(a,b,1) = af(1) + bf(2) = a + b \\tag{6.2}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EHơn nữa:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[f(n) = 1f(n) + 0f(n+1) = F(1,0,n) \\tag{7}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ENgừng lại một chút, tới đây ta vẫn chưa thể triển khai thành thuật toán hoàn chỉnh được, tại sao ư? Để ý \u003Cspan class=\"math inline\"\u003E\\((*)\\)\u003C\u002Fspan\u003E chỉ được định nghĩa với \u003Cspan class=\"math inline\"\u003E\\(2n\\)\u003C\u002Fspan\u003E, tức khi input là số chẵn, vậy còn lẻ thì sao? Đơn giản thôi, thế trường hợp input lẻ vào \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E rồi biến đổi, tức là:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\\begin{align*}\nF(a,b,2n+1)\n&= af(2n+1) + bf(n+1)\\\\\n&= a[f(n) + f(n+1)] + bf(n+1)\\\\\n&= af(n) + (a+b)f(n+1)\\\\\n&= F(a,a+b,n) \\tag{**}\n\\end{align*}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETa tổng hợp lại được như sau:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((7)\\)\u003C\u002Fspan\u003E cho ta định nghĩa tổng quát của \u003Cspan class=\"math inline\"\u003E\\(f(n)\\)\u003C\u002Fspan\u003E dựa trên \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((*)\\)\u003C\u002Fspan\u003E cho ta công thức đệ quy của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E đối với trường hợp input chẵn, tương tự với \u003Cspan class=\"math inline\"\u003E\\((**)\\)\u003C\u002Fspan\u003E ở trường hợp input lẻ.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cspan class=\"math inline\"\u003E\\((6.1)\\)\u003C\u002Fspan\u003E và \u003Cspan class=\"math inline\"\u003E\\((6.2)\\)\u003C\u002Fspan\u003E cho ta base case đệ quy của \u003Cspan class=\"math inline\"\u003E\\(F\\)\u003C\u002Fspan\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ECode thoai:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Efunction fusc(n) {\n\n    function F(a, b, k) {\n        if (k === 0)  \u002F\u002F See (6.1)\n            return b\n        else if (k === 1)  \u002F\u002F See (6.2)\n            return a + b\n        else if (k % 2 === 0)  \u002F\u002F See (*)\n            return F(a+b, b, Math.round(k \u002F 2))\n        else  \u002F\u002F See (**)\n            return F(a, a+b, Math.round((k-1) \u002F 2))\n    }\n\n    return F(1, 0, n)  \u002F\u002F See (7)\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESubmit thử:\u003Cbr\u003E\n\u003Cimg src=\"https:\u002F\u002Fi.imgur.com\u002FyoKDKTn.png\" alt=\"submit-code-img\"\u003E\u003Cbr\u003E\nNgon lành chứ hả, bonus cho mấy bạn thêm code Haskell nè:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-haskell\"\u003Efusc :: Integer -&gt; Integer\nfusc n = aux 1 0 n\n  where\n    aux _ b 0 = b\n    aux a b 1 = a+b\n    aux a b n\n      | even n = aux (a+b) b (n `div` 2)\n      | otherwise = aux a (a+b) ((n-1) `div` 2)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETui biết có một số bạn đọc tới đây rồi thì ngứa lắm, có thể bạn sẽ thắc mắc tại sao không dùng quy hoạch động? Thì đầu tiên là tui đang muốn nhấn mạnh về phương pháp này, nên quy hoạch động không nằm trong khuôn khổ của bài viết. Thứ 2 là quy hoạch động thật ra cũng không hiệu quả bằng đâu, tui cũng có thử implement quy hoạch động xong submit thử rồi nhưng nó tốn quá nhiều bộ nhớ, codewars không accept (người ta tính hết rồi ^^).\u003C\u002Fp\u003E\n\u003Ch2\u003EGóc nhìn của tui về phương pháp này\u003C\u002Fh2\u003E\n\u003Cp\u003ETrong pure functional programming language (FP) như Haskell thì không có vòng lặp cho bạn dùng, thay vào đó nếu bạn muốn lặp thì bạn phải xây dựng đệ quy. Mà thực tế có những tính năng bạn cần lặp vô hạn hoặc lặp rất nhiều lần, để không bị stack overflow trên những tính năng đó thì họ phải hướng tới tail recursion. Vậy làm sao để xây dựng tail recursion? ừa thì linh cảm, tâm linh là chính thôi, lấy ví dụ cho hàm tính giai thừa:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F Đệ quy thông thường\nfunction fact(n) {\n    if (n === 1)\n        return 1\n    else\n        return n * fact(n-1)\n}\n\n\u002F\u002F Tail recursion\nfunction fact(n, acc) {\n    if (n === 1)\n        return acc\n    else\n        return fact(n-1, acc*n)\n}\nfact(10, 1) \u002F\u002F tính 10!\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHàm đệ quy thông thường thì đơn giản rồi mình sẽ không nhắc tới nhé. Còn phần tail recursion ở dưới mình có thể hiểu là ta cần 1 biến nhân dồn kết quả lại, gọi là \u003Ccode\u003Eacc\u003C\u002Fcode\u003E (accumulator). \u003Ccode\u003Eacc\u003C\u002Fcode\u003E có giá trị ban đầu là 1, mỗi lần gọi đệ quy thì ta nhân \u003Ccode\u003En\u003C\u002Fcode\u003E vô \u003Ccode\u003Eacc\u003C\u002Fcode\u003E, đồng thời giảm \u003Ccode\u003En\u003C\u002Fcode\u003E xuống một đơn vị, rồi truyền vào đệ quy kế tiếp. Cứ truyền xuống như vậy, lúc này bạn sẽ thấy \u003Ccode\u003Eacc\u003C\u002Fcode\u003E mang giá trị của tích \u003Ccode\u003En(n-1)(n-2)...\u003C\u002Fcode\u003E và cũng là kết quả mình cần tìm khi \u003Ccode\u003En\u003C\u002Fcode\u003E giảm xuống 1.\u003C\u002Fp\u003E\n\u003Cp\u003EĐây cũng là pattern chung trong phương pháp tìm tail recursion, ta sẽ có biến tích luỹ \u003Ccode\u003Eacc\u003C\u002Fcode\u003E là tham số được truyền dần xuống, và nó sẽ đem theo kết quả cho đến khi chạm base case. Nhưng ta có thể thấy pattern trên chỉ do mình cảm giác và tưởng tượng (aka tâm linh) chứ không được chứng minh rõ ràng, và ban đầu mình cũng nghĩ mấy thứ này không thể chứng minh được cho đến khi gặp bài toán xịn xò mà mình đã giải quyết bên trên.\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\nGóc bài tập về nhà: Bạn có thể thử suy nghĩ cách chứng minh định nghĩa hàm fact(n, acc) bên trên là đúng dựa trên phương pháp chặt chẽ của bài viết. Và xây dựng lại tail recursion cho fib(n) dựa trên phương pháp tâm linh này, bạn sẽ bất ngờ vì nó cho cùng một kết quả đó.\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003ECảm ơn mấy bạn đã đọc hết đến đây (hoặc là do bạn lướt xuống và gặp được dòng này). Đây là bài viết đầu tiên trên blog của tui, tui xin nhận mọi ý kiến đóng góp, nhưng nếu bạn có ý định ném đá thì nên cân nhắc lời lẽ phù hợp với trái tim mỏng manh của tác giả 😢.\u003C\u002Fp\u003E\n",Array(3),0,10,3221225527,"2021-09-01T20:31:32Z")));