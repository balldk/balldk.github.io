__NUXT_JSONP__("/posts/vila", (function(a,b,c,d,e,f,g,h,i,j){return {data:[{post:{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}}],fetch:{},mutations:[["post\u002FsetPost",{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}]]}}(true,"vila","","## Một số ví dụ\n\nCâu lệnh cơ bản\n\n```\ncho A = [1..100]\n\nvới mỗi n thuộc A, n :\n\tnếu n % 3 == 1:\n\t\txuất n, \"chia 3 dư 1\"\n\tcòn nếu n % 3 == 2:\n\t\txuất n, \"chia 3 dữ 2\"\n\tcòn không:\n\t\txuất n, \"chia hết cho 3\"...","\u003Ch2\u003EMột số ví dụ\u003C\u002Fh2\u003E\n\u003Cp\u003ECâu lệnh cơ bản\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo A = [1..100]\n\nvới mỗi n thuộc A, n :\n\tnếu n % 3 == 1:\n\t\txuất n, &quot;chia 3 dư 1&quot;\n\tcòn nếu n % 3 == 2:\n\t\txuất n, &quot;chia 3 dữ 2&quot;\n\tcòn không:\n\t\txuất n, &quot;chia hết cho 3&quot;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETính hàm hợp, với \u003Cspan class=\"math inline\"\u003E\\((f.g)(x) = f(g(x))\\)\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo f(x) = 2x(x^2 - 2x)(3x - 5)\ncho g(x) = 5x\n\ncho a = 5\nxuất f.g(a)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003E2x(x^2 - 2x)(3x - 5)\u003C\u002Fcode\u003E là cách viết ngắn gọn hơn của \u003Ccode\u003E2*x*(x^2 - 2*x)*(3*x - 5)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ESử dụng list comprehension để định nghĩa mảng vô hạn các phần tử, với \u003Ccode\u003Efib[i]\u003C\u002Fcode\u003E là phần tử thứ \u003Ccode\u003Ei\u003C\u002Fcode\u003E trong dãy fibonacci\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuoc [3..] }\n\nvới mỗi n thuộc fib:\n    xuất n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EList comprehension có tính &ldquo;lazy&rdquo;,  tức là khi ta định nghĩa \u003Ccode\u003Efib\u003C\u002Fcode\u003E thì chưa phần tử nào trong mảng được tính cả, chỉ khi ta cần dùng tới phần tử nào thì phần tử đó mới được tính ra, do đó ta có thể dễ dàng tạo ra mảng vô hạn phần tử trong Vila\u003C\u002Fp\u003E\n\u003Ch2\u003ECài đặt\u003C\u002Fh2\u003E\n\u003Ch2\u003ECú pháp\u003C\u002Fh2\u003E\n\u003Ch3\u003EKhai báo biến\u003C\u002Fh3\u003E\n\u003Cp\u003EBiến được định nghĩa thông qua từ khóa \u003Ccode\u003Echo\u003C\u002Fcode\u003E, với cấu trúc như sau\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo &lt;tên biến&gt; = &lt;biểu thức&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EVí dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo x = 10\ncho ngày sinh = 15\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EMột số hằng số được định nghĩa sẵn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Exuất Pi \u002F\u002F 3.14159...\nxuất E  \u002F\u002F 2.71828...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EKhai báo hàm\u003C\u002Fh3\u003E\n\u003Cp\u003EKhai báo hàm tương đối giống với khai báo biến\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo &lt;tên hàm&gt;(&lt;danh sách các tham số&gt;) = &lt;biểu thức&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EVí dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo f(x,y,z) = 2x(x^2 - 2x + 1) - y^z\nxuất f(100, 5, 3)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EỞ ví dụ trên, hàm chỉ được định nghĩa ngắn gọn trong một hàng, để viết một số hàm phức tạp, cần thực hiện nhiều câu lệnh hơn, ta có thể dùng &ldquo;Biểu thức nhóm&rdquo;\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo f(x) = (cho a = 5; cho b = 6; a+b+x)\nxuất f(2) \u002F\u002F 13\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBiểu thức cuối cùng trong biểu thức nhóm sẽ là giá trị trả về cho toàn bộ biểu thức, ở ví dụ trên \u003Ccode\u003Ea+b+x = 5+6+2 = 13\u003C\u002Fcode\u003E là giá trị của \u003Ccode\u003Ef(2)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETrên thực tế ta sẽ tách các câu lệnh trong biểu thức nhóm bằng cách xuống dòng\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F Trả về đúng nếu n là số chẵn, sai nếu n là số lẻ\ncho là chẵn(n) = (\n\tcho two = 2\n\tnếu n % two == 0:\n\t\t=&gt; đúng\n\tsai\n)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDấu suy ra \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E có ý nghĩa tương đương với câu lệnh \u003Ccode\u003Ereturn\u003C\u002Fcode\u003E ở những ngôn ngữ khác, nếu gặp \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E thì biểu thức nhóm sẽ kết thúc và lấy biểu thức sau \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E làm giá trị trả về\u003C\u002Fp\u003E\n\u003Cp\u003EMột số hàm được định nghĩa sẵn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Exuất cos(Pi)  \u002F\u002F -1\nxuất sin(Pi)  \u002F\u002F 0\nxuất tan(Pi)  \u002F\u002F 0\nxuất E^ln(2)  \u002F\u002F 2\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003ECác kiểu dữ liệu cơ bản\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F Số nguyên\n15\n\u002F\u002F số thực\n3.14\n\u002F\u002F Phân số\n3\u002F14\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EPhép toán\u003C\u002Fh3\u003E\n\u003Ch4\u003ESố học\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo a = 15\ncho b = 3\u002F5\n\nxuất a + b  \u002F\u002F 13\u002F2\nxuất a - b  \u002F\u002F 3\u002F2\nxuất a * b  \u002F\u002F 10\nxuất a \u002F b  \u002F\u002F 8\u002F5\nxuất a ^ b  \u002F\u002F 32\nxuất a % 7  \u002F\u002F 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003ELogic\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode\u003Exuất 1 == 2  \u002F\u002F sai\nxuất 1 != 2  \u002F\u002F đúng\nxuất 1 &lt; 1   \u002F\u002F sai\nxuất 1 &lt;= 1  \u002F\u002F đúng\nxuất 1 &gt; 1   \u002F\u002F sai\nxuất 1 &gt;= 1  \u002F\u002F đúng\n\nxuất đúng và sai  \u002F\u002F sai\nxuất đúng hay sai \u002F\u002F đúng\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n",null,0,2,2415919190,"2022-08-16T20:32:35Z")));