__NUXT_JSONP__("/posts/vanvo", (function(a,b,c,d,e,f,g,h,i,j){f[0]="project";return {data:[{post:{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}}],fetch:{},mutations:[["post\u002FsetPost",{name:b,title:c,description:d,content:e,tags:f,comment_count:g,allow_comment:a,is_publish:a,read_time:h,id:i,created_at:j}]]}}(true,"vanvo","VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt","Tất tần tật về ngôn ngữ lập trình VanVo (Văn Vở).","\u003Cp\u003EVanVo (Văn Vở) là ngôn ngữ lập trình được thiết kế với cú pháp thuần Việt, nhưng không chỉ đơn giản là dịch lại một cách gượng gạo từ các ngôn ngữ khác, mình cố gắng để thiết kế một ngôn ngữ sao cho các câu lệnh trông tự nhiên như tiếng Việt nhất có thể, thuận tiện cho người Việt nhất có thể. Điển hình là bạn có thể đặt tên định danh có khoảng trắng như \u003Ccode\u003Esố nguyên tố\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003ENgôn ngữ sẽ có hơi thiên hướng toán học, những bạn học toán có thể sẽ cảm thấy quen thuộc hơn, vì mình định hướng ngôn ngữ được sử dụng như một CAS (Computer Algebra System). Tuy nhiên VanVo vẫn có thể dùng như một ngôn ngữ đa mục đích (General-purpose language) thông thường.\u003C\u002Fp\u003E\n\u003Ch2\u003EĐiểm qua một số tính năng của VanVo\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003EHỗ trợ những câu lệnh rẽ nhánh, cấu trúc lặp, cấu trúc dữ liệu và phép toán cơ bản.\u003C\u002Fli\u003E\n\u003Cli\u003EHỗ trợ phân số và số phức.\u003C\u002Fli\u003E\n\u003Cli\u003ECó thể đặt tên định danh có khoảng trắng như \u003Ccode\u003Esố nguyên tố\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EKhông cần \u003Ccode\u003E;\u003C\u002Fcode\u003E ở cuối mỗi câu lệnh, và các khối lệnh sẽ được xác định bởi mức thụt dòng (indent level) như Python.\u003C\u002Fli\u003E\n\u003Cli\u003EPhép nhân giữa hằng số, biến và mở ngoặc có thể lược bỏ, ví dụ \u003Ccode\u003E2x(x-1)\u003C\u002Fcode\u003E sẽ tương đương với \u003Ccode\u003E2*x*(x-1)\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EList comprehension như \u003Ccode\u003E{ n*m | n thuộc [1..10], m thuộc [1..10], n != m }\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003ELazy evaluation.\u003C\u002Fli\u003E\n\u003Cli\u003ECác thao tác và phép toán trên tập hợp như hội, giao, hiệu, tích Descartes.\u003C\u002Fli\u003E\n\u003Cli\u003EGạch chân chính xác vị trí có lỗi khi chạy chương trình.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EMột số ví dụ minh họa\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003EVí dụ 1:\u003C\u002Fstrong\u003E Xét tính chia hết của n cho 2 và 3, với n là các số nguyên trong khoảng \u003Cspan class=\"math inline\"\u003E\\([1,100]\\)\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = [1..100]\n\nvới mỗi n thuộc A:\n\tnếu n % 2 == 0:\n\t\txuất n, &quot;chia hết cho 2&quot;\n\tcòn nếu n % 3 == 0:\n\t\txuất n, &quot;chia hết cho 3&quot;\n\tcòn không:\n\t\txuất n, &quot;không chia hết cho cả 2 và 3&quot;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003EVí dụ 2:\u003C\u002Fstrong\u003E Tính giá trị của hàm hợp, với \u003Cspan class=\"math inline\"\u003E\\((f.g)(x) = f(g(x))\\)\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo f(x) = 2x(x^2 - 2x)(3x - 5)\ncho g(x) = 5x\n\ncho a = 5\nxuất f.g(a)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003E2x(x^2 - 2x)(3x - 5)\u003C\u002Fcode\u003E là cách viết ngắn gọn hơn của \u003Ccode\u003E2*x*(x^2 - 2*x)*(3*x - 5)\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVí dụ 3:\u003C\u002Fstrong\u003E Sử dụng list comprehension để định nghĩa mảng vô hạn các phần tử, với \u003Ccode\u003Efib[i]\u003C\u002Fcode\u003E là phần tử thứ \u003Ccode\u003Ei\u003C\u002Fcode\u003E trong dãy fibonacci\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuộc [3..] }\n\nvới mỗi n thuộc fib:\n    xuất n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EList comprehension có tính &ldquo;lazy&rdquo;,  tức là chỉ khi ta cần dùng phần tử nào trong mảng thì phần tử đó mới được tính ra, do đó ta có thể dễ dàng định nghĩa ra mảng vô hạn phần tử trong VanVo.\u003C\u002Fp\u003E\n\u003Ch2\u003ECài đặt\u003C\u002Fh2\u003E\n\u003Ch2\u003ECú pháp\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003ELưu ý\u003C\u002Fstrong\u003E: vì mình có sử dụng ligature font cho code trên web nên các kí hiệu như =&gt;, &gt;=, &lt;=, ==, != sẽ trở thành \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E, \u003Ccode\u003E&gt;=\u003C\u002Fcode\u003E, \u003Ccode\u003E&lt;=\u003C\u002Fcode\u003E, \u003Ccode\u003E==\u003C\u002Fcode\u003E, \u003Ccode\u003E!=\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch3\u003EQuy định đặt tên và từ khóa\u003C\u002Fh3\u003E\n\u003Cp\u003ETên định danh là tên được bạn đặt cho biến và hàm trong chương trình, VanVo bao gồm các quy tắc đặt tên định danh như sau:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECó thể chứa các kí tự \u003Ccode\u003Ea-z\u003C\u002Fcode\u003E, \u003Ccode\u003EA-Z\u003C\u002Fcode\u003E, \u003Ccode\u003E0-9\u003C\u002Fcode\u003E, \u003Ccode\u003E_\u003C\u002Fcode\u003E và toàn bộ bảng chữ cái cũng như dấu trong tiếng Việt.\u003C\u002Fli\u003E\n\u003Cli\u003EKhông được bắt đầu bằng một chữ số.\u003C\u002Fli\u003E\n\u003Cli\u003EKhác với hầu hết các ngôn ngữ khác, VanVo cho phép bạn đặt tên định danh với khoảng trắng, nhưng có một lưu ý là khoảng trắng giữa các từ không quan trọng, ví dụ \u003Ccode\u003Enguyên tố\u003C\u002Fcode\u003E và \u003Ccode\u003Enguyên   tố \u003C\u002Fcode\u003E là hai tên định danh giống nhau.\u003C\u002Fli\u003E\n\u003Cli\u003EPhân biệt hoa thường (case sensitive).\u003C\u002Fli\u003E\n\u003Cli\u003EKhông được đặt tên định danh trùng với từ khóa.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EDanh sách các từ khóa trong VanVo:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Echo\u003C\u002Fcode\u003E, \u003Ccode\u003Ethuộc\u003C\u002Fcode\u003E, \u003Ccode\u003Evà\u003C\u002Fcode\u003E, \u003Ccode\u003Ehay\u003C\u002Fcode\u003E, \u003Ccode\u003Evới\u003C\u002Fcode\u003E, \u003Ccode\u003Evới mỗi\u003C\u002Fcode\u003E, \u003Ccode\u003Enếu\u003C\u002Fcode\u003E, \u003Ccode\u003Ecòn nếu\u003C\u002Fcode\u003E, \u003Ccode\u003Ecòn không\u003C\u002Fcode\u003E, \u003Ccode\u003Eđúng\u003C\u002Fcode\u003E, \u003Ccode\u003Esai\u003C\u002Fcode\u003E, \u003Ccode\u003Enhập\u003C\u002Fcode\u003E, \u003Ccode\u003Exuất\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003ENote:\u003C\u002Fstrong\u003E Bạn có thể viết các từ khóa không dấu, ví dụ \u003Ccode\u003Eneu\u003C\u002Fcode\u003E, \u003Ccode\u003Evoi\u003C\u002Fcode\u003E là các từ khóa hợp lệ. Tuy nhiên bạn chỉ có thể viết đầy đủ dấu hoặc là viết không dấu hoàn toàn, ví dụ \u003Ccode\u003Eđung\u003C\u002Fcode\u003E không phải là một từ khóa hợp lệ vì thiếu dấu sắc.\u003C\u002Fp\u003E\n\u003Ch3\u003EKhai báo biến\u003C\u002Fh3\u003E\n\u003Cp\u003EBiến được định nghĩa thông qua từ khóa \u003Ccode\u003Echo\u003C\u002Fcode\u003E, với cấu trúc như sau\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003Echo &lt;tên biến&gt; = &lt;biểu thức&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EVí dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo x = 10.2\ncho ngày sinh = 15\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EMột số hằng số được định nghĩa sẵn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Exuất Pi \u002F\u002F 3.14159...\nxuất E  \u002F\u002F 2.71828...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EKhai báo hàm\u003C\u002Fh3\u003E\n\u003Cp\u003EKhai báo hàm tương đối giống với khai báo biến\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003Echo &lt;tên hàm&gt;(&lt;danh sách các tham số&gt;) = &lt;biểu thức&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EVí dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo f(x,y,z) = 2x(x^2 - 2x + 1) - y^z\nxuất f(100, 5, 3)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EỞ ví dụ trên, hàm chỉ được định nghĩa ngắn gọn trong một hàng, để viết một số hàm phức tạp, cần thực hiện nhiều câu lệnh hơn, ta có thể dùng &ldquo;Biểu thức nhóm&rdquo;\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo f(x) = (cho a = 5; cho b = 6; a+b+x)\nxuất f(2) \u002F\u002F 13\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBiểu thức cuối cùng trong biểu thức nhóm sẽ là giá trị trả về cho toàn bộ biểu thức, ở ví dụ trên \u003Ccode\u003Ea+b+x = 5+6+2 = 13\u003C\u002Fcode\u003E là giá trị của \u003Ccode\u003Ef(2)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ETrên thực tế ta sẽ xuống dòng tách các câu lệnh trong biểu thức nhóm\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003E\u002F\u002F Trả về đúng, nếu n là số chẵn, sai nếu n là số lẻ\ncho là chẵn(n) = (\n\tcho two = 2\n\tnếu n % two == 0:\n\t\t=&gt; đúng\n\tsai\n)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDấu suy ra \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E có ý nghĩa tương đương với câu lệnh \u003Ccode\u003Ereturn\u003C\u002Fcode\u003E ở những ngôn ngữ khác, khi gặp \u003Ccode\u003E=&gt;\u003C\u002Fcode\u003E thì biểu thức nhóm sẽ kết thúc và trả về giá trị cho biểu thức\u003C\u002Fp\u003E\n\u003Cp\u003EMột số hàm được định nghĩa sẵn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Exuất cos(Pi)  \u002F\u002F -1\nxuất sin(Pi)  \u002F\u002F 0\nxuất tan(Pi)  \u002F\u002F 0\nxuất E^ln(2)  \u002F\u002F 2\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003ECác kiểu dữ liệu cơ bản\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003E\u002F\u002F Số nguyên\n15\n\u002F\u002F số thực\n3.14\n\u002F\u002F Phân số\n3\u002F14\n\u002F\u002F Số phức\n3\u002F2 - 2I\n\u002F\u002F Logic\nđúng\nsai\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EPhép toán\u003C\u002Fh3\u003E\n\u003Ch4\u003ESố học\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo a = 4\ncho b = 5\u002F2\n\nxuất a + b  \u002F\u002F 13\u002F2\nxuất a - b  \u002F\u002F 3\u002F2\nxuất a * b  \u002F\u002F 10\nxuất a \u002F b  \u002F\u002F 8\u002F5\nxuất a ^ b  \u002F\u002F 32\nxuất a % 7  \u002F\u002F 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003ELogic\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Exuất 1 == 2  \u002F\u002F sai\nxuất 1 != 2  \u002F\u002F đúng\nxuất 1 &lt; 1   \u002F\u002F sai\nxuất 1 &lt;= 1  \u002F\u002F đúng\nxuất 1 &gt; 1   \u002F\u002F sai\nxuất 1 &gt;= 1  \u002F\u002F đúng\n\nxuất đúng và sai  \u002F\u002F sai\nxuất đúng hay sai \u002F\u002F đúng\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003EToán tử ba ngôi\u003C\u002Fh4\u003E\n\u003Cp\u003ECấu trúc của toán tử ba ngôi\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003E&lt;biểu thức 1&gt; nếu &lt;điều kiện&gt; còn không &lt;biểu thức 2&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENếu \u003Ccode\u003E&lt;điều kiện&gt;\u003C\u002Fcode\u003E thỏa thì toán tử ba ngồi sẽ trả về giá trị của \u003Ccode\u003E&lt;biểu thức 1&gt;\u003C\u002Fcode\u003E, còn không thì trả về giá trị của \u003Ccode\u003E&lt;biểu thức 2\u003C\u002Fcode\u003E&gt;. Ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo gtln(a, b) = a nếu a &gt; b còn không b\nxuất gtln(2, 3)  \u002F\u002F 3\t\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003ECâu lệnh điều kiện\u003C\u002Fh3\u003E\n\u003Cp\u003ECâu lệnh điều kiện có cấu trúc như sau\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003Enếu &lt;điều kiện 1&gt;:\n\t...\ncòn nếu &lt;điều kiện 2&gt;:\n\t...\ncòn không:\n\t...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003E...\u003C\u002Fcode\u003E ở đây là khối lệnh, một khối lệnh được xác định bởi mức thụt dòng (indent level) của đoạn code. Không như Python, ở trong VanVo thì indent size được cố định là 4, tab cũng được chương trình mặc định hiểu là 4 spaces.\u003C\u002Fp\u003E\n\u003Cp\u003EVí dụ: xác định \u003Ccode\u003En\u003C\u002Fcode\u003E là âm, dương hay 0\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo n = 100\n\nnếu n &lt; 0:\n\txuất n, &quot;là số âm&quot;\ncòn nếu n &gt; 0:\n\txuất n, &quot;là số dương&quot;\ncòn không:\n\txuất n, &quot;là 0&quot;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003ECấu trúc lặp\u003C\u002Fh3\u003E\n\u003Cp\u003ETrong VanVo có hai cấu trúc lặp là \u003Ccode\u003Evới\u003C\u002Fcode\u003E và \u003Ccode\u003Evới mỗi\u003C\u002Fcode\u003E, \u003Ccode\u003Evới\u003C\u002Fcode\u003E có ý nghĩa tương đương với \u003Ccode\u003Ewhile\u003C\u002Fcode\u003E ở những ngôn ngữ khác, còn \u003Ccode\u003Evới mỗi\u003C\u002Fcode\u003E sẽ ý nghĩa tương tự như vòng lặp \u003Ccode\u003Efor\u003C\u002Fcode\u003E nhưng không giống hoàn toàn mà sẽ có những đặc trưng riêng.\u003C\u002Fp\u003E\n\u003Ch4\u003EVới\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Evới\u003C\u002Fcode\u003E có cấu trúc như sau\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003Evới &lt;danh sách điều kiện&gt;:\n\t...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EVòng lặp sẽ được thực hiện cho đến khi một trong các điều kiện của \u003Ccode\u003E&lt;danh sách điều kiện&gt;\u003C\u002Fcode\u003E không thỏa thì vòng lặp dừng lại.\u003C\u002Fp\u003E\n\u003Cp\u003EVí dụ: xuất ra các số trong khoảng \u003Cspan class=\"math inline\"\u003E\\([0,100)\\)\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo i = 0\nvới 0 &lt;= i, i &lt; 100:\n\txuất i\n\ti = i + 1\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EĐiều kiện \u003Ccode\u003E0 &lt;= i, i &lt; 100\u003C\u002Fcode\u003E tương đương với \u003Ccode\u003E0 &lt;= i và i &lt; 100\u003C\u002Fcode\u003E. Ngoài ra bạn có thể sử dụng chaining comparison operator \u003Ccode\u003E0 &lt;= i &lt; 100\u003C\u002Fcode\u003E để ngắn gọn hơn.\u003C\u002Fp\u003E\n\u003Ch4\u003EVới mỗi\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Evới mỗi\u003C\u002Fcode\u003E có cấu trúc như sau\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003Evới mỗi &lt;biến&gt; thuộc &lt;tập đếm được&gt;, &lt;ràng buộc&gt;,...:\n\t...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHãy thử nhìn vào ví dụ trước nhé, chương trình sau sẽ xuất ra các số chẵn trong khoảng \u003Cspan class=\"math inline\"\u003E\\([1,100]\\)\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Evới mỗi n thuộc [1..100], x % 2 == 0:\n\txuất n\n\n\u002F\u002F Output:\n2\n4\n6\n...\n100\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EỞ chương trình trên, \u003Ccode\u003En\u003C\u002Fcode\u003E lặp qua từng phần tử trong \u003Ccode\u003E[1..100]\u003C\u002Fcode\u003E, với \u003Ccode\u003E[1..100]\u003C\u002Fcode\u003E là tập các số nguyên trong khoảng từ 1 đến 100. Nếu \u003Ccode\u003En\u003C\u002Fcode\u003E thỏa mọi ràng buộc được cho thì khối lệnh bên trong sẽ được thực hiện (trong trường hợp này thì ràng buộc là \u003Ccode\u003En % 2 == 0\u003C\u002Fcode\u003E). Dĩ nhiên không phải tập hợp nào cũng có thể lặp qua được, phần tiếp theo sẽ giải thích vấn đề này chi tiết hơn.\u003C\u002Fp\u003E\n\u003Cp\u003EBạn có thể lặp qua nhiều tập và có nhiều ràng buộc cùng một lúc, lấy ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Evới mỗi n thuộc [1..5], m thuộc [3..5], n % 2 == 0, m % 2 == 1:\n\txuất n, m\n\n\u002F\u002F Output:\n2 3\n2 5\n4 3\n4 5\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003ETập hợp\u003C\u002Fh3\u003E\n\u003Cp\u003EBan đầu khi mình phát thảo ý tưởng cho ngôn ngữ này thì mình lấy tập hợp, các phép toán và mệnh đề trên tập hợp làm tư tưởng chính. Nhưng càng về sau thì mình nhận ra là để xây dựng khái niệm tập hợp chuẩn thì tương đối không hiệu quả, và hầu hết các trường hợp thì mảng vẫn hữu dụng hơn, cho nên khái niệm mảng và tập hợp trong VanVo mình sẽ dùng trùng lặp nhau, bạn đọc nên hiểu hai khái niệm này trong VanVo là một, nhưng chúng không tương đương với khái niệm tập hợp thông thường.\u003C\u002Fp\u003E\n\u003Cp\u003ETrong VanVo có những tập hợp được gọi là \u003Cstrong\u003ETập đếm được\u003C\u002Fstrong\u003E, bạn có thể truy cập chỉ số (indexing) và lặp qua tập đếm được, những tập còn lại được gọi là \u003Cstrong\u003ETập không đếm được\u003C\u002Fstrong\u003E. Sau đây là các loại tập hợp hiện có trong VanVo.\u003C\u002Fp\u003E\n\u003Ch4\u003EKhoảng Thực (Real interval)\u003C\u002Fh4\u003E\n\u003Cp\u003EKhoảng thực \u003Cspan class=\"math inline\"\u003E\\([a,b]\\)\u003C\u002Fspan\u003E là tập các số thực \u003Cspan class=\"math inline\"\u003E\\(x\\)\u003C\u002Fspan\u003E sao cho \u003Cspan class=\"math inline\"\u003E\\(a\\leq x \\leq b\\)\u003C\u002Fspan\u003E, bạn có thể dùng toán tử \u003Ccode\u003Ethuộc\u003C\u002Fcode\u003E để xét xem một giá trị \u003Cspan class=\"math inline\"\u003E\\(x\\)\u003C\u002Fspan\u003E có thuộc vào một tập hay không, lấy ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = [0,5]\n\nxuất 2 thuộc A    \u002F\u002F đúng\nxuất 5 thuộc A    \u002F\u002F đúng\nxuất -1 thuộc A   \u002F\u002F sai\nxuất I thuộc A    \u002F\u002F sai\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EKhoảng thực là Tập không đếm được.\u003C\u002Fp\u003E\n\u003Ch4\u003EKhoảng cách đều\u003C\u002Fh4\u003E\n\u003Cp\u003EKhoảng cách đều \u003Cspan class=\"math inline\"\u003E\\([a..b]\\)\u003C\u002Fspan\u003E là tập các số \u003Cspan class=\"math inline\"\u003E\\(n\\)\u003C\u002Fspan\u003E sao cho \u003Cspan class=\"math inline\"\u003E\\(a \\leq n \\leq b\\)\u003C\u002Fspan\u003E, và các phần tử liên tiếp cách nhau đúng một đơn vị, lấy ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo a = 1.2\ncho b = 5\ncho A = [a..b]\n\nvới mỗi x thuộc A:\n\txuất x\n\nxuất b thuộc A\n\n\u002F\u002F Output:\n1.2\n2.2\n3.2\n4.2\nsai\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETừ ví dụ trên ta có thể nhận thấy Khoảng cách đều là một Tập đếm được.\u003C\u002Fp\u003E\n\u003Cp\u003EBạn có thể đặt bước nhảy (step) cho một Khoảng với cú pháp \u003Ccode\u003E[a..b, step]\u003C\u002Fcode\u003E, ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Evới mỗi n thuộc [0..4, 2]:\n\txuất n\n\n\u002F\u002F Output:\n0\n2\n4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003EDanh sách (List)\u003C\u002Fh4\u003E\n\u003Cp\u003EDanh sách sẽ tương đối giống mảng thông thường ở những ngôn ngữ khác, với cú pháp \u003Ccode\u003E{a, b, c, ...}\u003C\u002Fcode\u003E, ví dụ\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = {1, 2, &quot;hello&quot;, đúng}\n\nvới mỗi phần tử thuộc A:\n\txuất phần tử\n\n\u002F\u002F Output:\n1\n2\n&quot;hello&quot;\nđúng\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003EList comprehension\u003C\u002Fh4\u003E\n\u003Cp\u003EMình cũng không rõ phải dịch khái niệm này ra như thế nào, nhưng riêng trong VanVo thì list comprehension sẽ có cấu trúc giống y như cách chúng ta biểu diễn tập hợp trong toán\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bnf\"\u003E{ &lt;biểu thức&gt; | &lt;biến&gt; thuộc &lt;tập đếm được&gt;, &lt;ràng buộc&gt; }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ECó thể thấy cấu trúc của list comprehension và vòng lặp &ldquo;với mỗi&rdquo; có sự tương đồng nhất định, vì chúng thật sự có cơ chế gần giống nhau, ta có thể hiểu \u003Ccode\u003E&lt;biểu thức&gt;\u003C\u002Fcode\u003E ở đây là phần thân của vòng lặp, và giá trị của \u003Ccode\u003E&lt;biểu thức&gt;\u003C\u002Fcode\u003E sẽ là từng phần tử trong tập trên.\u003C\u002Fp\u003E\n\u003Cp\u003EVí dụ: Xây dựng tập các số nguyên dương chẵn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = { n | n thuộc [1..], n % 2 == 0 }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHoặc đơn giản hơn là\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = { 2n | n thuộc [1..] }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBạn có thể nghi ngờ rằng khi chạy câu lệnh trên thì chương trình bị vướng vào vòng lặp vô hạn và không thể chạy tiếp những câu lệnh khác, nhưng thực tế thì chương trình vẫn tiếp tục chạy những câu lệnh tiếp theo, bạn có thể thao tác trên \u003Ccode\u003EA\u003C\u002Fcode\u003E, hay lấy ra bất kì phần tử nào trong tập \u003Ccode\u003EA\u003C\u002Fcode\u003E đó mà bạn muốn. Lý do ta có thể làm được việc này là vì VanVo có hỗ trợ lazy evaluation cho list comprehension, chỉ khi bạn cần phần tử nào thì chương trình mới tính ra phần tử đó (và các phần tử trước) rồi lưu lại. Vì vậy ta có thể dễ dàng định nghĩa ra mảng vô hạn các phần tử trong VanVo.\u003C\u002Fp\u003E\n\u003Ch4\u003ECác thao tác và phép toán trên tập hợp\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cstrong\u003ELực lượng (#)\u003C\u002Fstrong\u003E: Hiện tại chỉ có thể lấy lực lượng (số phần tử) trên Tập đếm được\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo A = [1..100, 2]\ncho B = {3, 5, 7}\n\n#A      \u002F\u002F 50\n#B      \u002F\u002F 3\n#(A-B)  \u002F\u002F\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003EChỉ số:\u003C\u002Fstrong\u003E Tương tự, chỉ có Tập đếm được mới có chỉ số\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Echo A = [1..100, 2]\ncho fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuoc [3..] }\n\nA[1]     \u002F\u002F 3\nfib[50]  \u002F\u002F 12586269025\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003EPhép hội (+)\u003C\u002Fstrong\u003E: Đối với trường hợp lấy hội 2 Tập đếm được thì ta hiểu đây là phép hợp nối mảng sẽ chính xác hơn\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = {1, 2} + [6..10]  \u002F\u002F {1, 2, 6, 7, 8, 9, 10}\ncho B = {1, 2} + [6, 10]  \u002F\u002F B là Tập không đếm được\n\n8.2 thuộc B  \u002F\u002F đúng\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003EPhép hiệu (-)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = [1..9] - [4, 6]  \u002F\u002F {1, 2, 3, 7, 8, 9}\ncho B = [1, 9] - [4, 6]  \u002F\u002F B là Tập không đếm được\n\n7 thuộc B  \u002F\u002F đúng\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003ETích Descartes (*)\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vanvo\"\u003Echo A = [1..3]\ncho B = [1..3]\n\nA*B\n\u002F\u002F { {1, 1}, {1, 2}, {1, 3}, \n\u002F\u002F   {2, 1}, {2, 2}, {2, 3},\n\u002F\u002F   {3, 1}, {3, 2}, {3, 3} }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003ETúm cái váy\u003C\u002Fh2\u003E\n\u003Cp\u003EHiện tại ngôn ngữ vẫn còn sơ khai và sẽ còn nhiều thay đổi trong thời gian tới, nhìn chung thì dự án này cũng chỉ là sở thích cá nhân thôi, mình không có ý định tạo ra với mục đích thay thế bất kì ngôn ngữ nào trên thị trường cả nên các bạn có ý kiến đóng góp hay ý tưởng gì thì cồm men bên dưới nhẹ nhàng hoặc có thể tạo issue trên github nhé.\u003C\u002Fp\u003E\n",Array(1),2,11,3758096490,"2022-08-18T18:06:33Z")));