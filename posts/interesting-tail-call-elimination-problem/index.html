<!doctype html>
<html data-n-head-ssr lang="vi" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22vi%22%7D%7D">
  <head>
    <meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="og:image" property="og:image" content="https://balldk.github.io/meta-img.png"><meta data-n-head="ssr" data-hid="og:site_name" property="og:site_name" content="Góc nhỏ của K"><meta data-n-head="ssr" data-hid="description" name="description" content="Một bài toán thú vị về tối ưu đệ quy giúp tui có góc nhìn khác về tail call elimination như thế nào."><meta data-n-head="ssr" data-hid="og:title" property="og:title" content="Góc nhìn khác về tail call elimination | Góc nhỏ của K"><meta data-n-head="ssr" data-hid="og:description" property="og:description" content="Một bài toán thú vị về tối ưu đệ quy giúp tui có góc nhìn khác về tail call elimination như thế nào."><meta data-n-head="ssr" data-hid="keywords" name="keywords" content="algorithm, recursion, functional-programming"><meta data-n-head="ssr" data-hid="og:type" property="og:type" content="article"><title>Góc nhìn khác về tail call elimination | Góc nhỏ của K</title><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/logo.svg"><link data-n-head="ssr" rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="https://fonts.googleapis.com"><link data-n-head="ssr" rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Signika:wght@300;400;500;600;700&display=swap"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap"><link data-n-head="ssr" rel="stylesheet" href='https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"'><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script data-n-head="ssr" async src="https://www.googletagmanager.com/gtag/js?id=G-SH612LCBTQ"></script><link rel="preload" href="/_nuxt/2d9de3f.js" as="script"><link rel="preload" href="/_nuxt/8538b13.js" as="script"><link rel="preload" href="/_nuxt/css/04e2415.css" as="style"><link rel="preload" href="/_nuxt/0a5dc33.js" as="script"><link rel="preload" href="/_nuxt/css/f597ee7.css" as="style"><link rel="preload" href="/_nuxt/761ab04.js" as="script"><link rel="preload" href="/_nuxt/css/e4d0367.css" as="style"><link rel="preload" href="/_nuxt/a041fa1.js" as="script"><link rel="preload" href="/_nuxt/2724976.js" as="script"><link rel="preload" href="/_nuxt/2d0a0ae.js" as="script"><link rel="stylesheet" href="/_nuxt/css/04e2415.css"><link rel="stylesheet" href="/_nuxt/css/f597ee7.css"><link rel="stylesheet" href="/_nuxt/css/e4d0367.css"><link rel="preload" href="/_nuxt/static/1685628949/posts/interesting-tail-call-elimination-problem/state.js" as="script"><link rel="preload" href="/_nuxt/static/1685628949/posts/interesting-tail-call-elimination-problem/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1685628949/manifest.js" as="script">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><article><div class="head-bar"><div class="post-logo-container"><a href="/" class="post-logo logo nuxt-link-active"></a></div></div> <div class="post-container"><!----> <div class="post-content-container"><div class="post-header"><h1 class="post-title">Góc nhìn khác về tail call elimination</h1> <p class="post-info"><i class="far fa-edit"></i> Đăng vào 2-9-2021</p> <p class="post-info"><i class="far fa-clock"></i> 10 phút đọc</p> <!----></div> <div class="post-content"><p>Tui thì đó giờ hay cày rank trên <a href="https://www.codewars.com">Codewars</a>, chủ yếu là vì giao diện của nó ngầu lòi hơn ba mấy web thuật toán chán ngắt khác 😄 Chơi một thời gian thì tui cũng lên được 4 kyu và gặp phải bài toán này <a href="https://www.codewars.com/kata/57040e445a726387a1001cf7">The fusc function - Part 2</a>. Bài này thú vị ở chỗ, thay vì như thông thường họ chỉ đưa mình đề bài, thì bài này họ còn đưa cho mình một bài khác ví dụ mẫu cho phương pháp mà họ muốn mình dùng. Nói chung là giải xong sẽ học được phương pháp gì đó mới, chỉ tiếc là tui lúc đó đã quyết định gập máy đi ngủ 🙂 Mới đầu năm nay thì tui thử mở ra làm lại, và congrats, não tui đã được thông, giờ tui đi thông ngược lại cho mấy bạn đây.</p>
<p>Trong bài viết này, tui sẽ đi giải quyết bài toán trên trước, mục tiêu bài toán là đưa từ một hàm đệ quy thành một hàm đệ quy đuôi (tail call elimination), đừng lo, tui sẽ giải thích kĩ hơn những thuật ngữ này ở phía dưới. Sau đó tui sẽ chia sẻ một chút về góc nhìn của tui tại sao phương pháp của bài toán này khá độc đáo so với thực tế. Okay triển thôi nào!</p>
<h2>Nội dung bài toán</h2>
<p>Dành cho những con người chây lười không chịu bấm vào link đọc trước (ừa tui đang nói bạn đó) thì tui sẽ trình bày lại bài toán ở đây luôn, <del>chứ không phải vì tui muốn bài mình dài ra đâu nha</del>. Với lại tui cũng sẽ làm rõ một số chỗ mà bài viết gốc không đề cập tới.</p>
<p>Cho hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> được định nghĩa như sau:</p>
<p><span class="math display">\[\begin{cases}
\operatorname{fusc}(0) = 0\\
\operatorname{fusc}(1) = 1\\
\operatorname{fusc}(2n) = \operatorname{fusc}(n)\\
\operatorname{fusc}(2n + 1) = \operatorname{fusc}(n) + \operatorname{fusc}(n + 1)\\
\end{cases}
\]</span></p>
<p>Việc của bạn là hãy viết lại và tối ưu hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> trên. Nhớ rằng <span class="math inline">\(n\)</span> sẽ có giá trị rất lớn, cụ thể thì <span class="math inline">\(n\)</span> sẽ lớn hơn 1000 bit (đối với Javascript) và 52 bit (đối với PHP), nên là cần lưu ý tới vấn đề stack overflow và timeouts.</p>
<h2>Gợi ý phương pháp</h2>
<blockquote>
Phần này trong lúc đọc mấy bạn không cần quá hoang mang những thứ như là tại sao phải đưa hai vế về cùng dạng, rồi tại sao phải đặt thêm biến a, b các thứ đâu, cứ đọc đến cuối là mọi thứ sẽ trở nên make sense thôi.
</blockquote>
<p>Tưởng tượng thay vì đề bài là hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> mà là hàm <span class="math inline">\(\operatorname{fib}(n)\)</span> (trả về <a href="https://en.wikipedia.org/wiki/Fibonacci_number">số Fibonacci</a> thứ <span class="math inline">\(n\)</span>), thì lúc này hàm được định nghĩa như sau:</p>
<p><span class="math display">\[\begin{cases}
\operatorname{fib}(0) = 1 & (1)\\
\operatorname{fib}(1) = 1 & (2)\\
\operatorname{fib}(n + 2) = \operatorname{fib}(n) + \operatorname{fib}(n + 1)\quad (n \geq 0) & (3)
\end{cases}
\]</span></p>
<p>Nếu dùng trực tiếp định nghĩa trên thì không được tối ưu cho lắm. Dĩ nhiên bạn hoàn toàn có thể dùng quy hoạch động, nhưng làm vậy thì lại tốn thêm bộ nhớ không cần thiết, nên là chúng ta sẽ cố thử tìm đệ quy đuôi (<a href="https://www.geeksforgeeks.org/tail-recursion">tail recursion</a>) cho bài toán này.</p>
<blockquote>Lại là góc nhỏ cho những con lười không chịu bấm vào đọc trước định nghĩa của tail recursion đây, thì tail recursion là loại hàm đệ quy mà việc gọi đệ quy là điều cuối cùng hàm đó thực hiện. Lấy ví dụ:</blockquote>
<pre><code class="language-js">// Đây không là tail recursion vì sau khi gọi đệ quy
// fact(n-1) thì hàm phải thực hiện thêm phép nhân
// với n nữa mới kết thúc
function fact(n) {
    if (n === 1)
        return 1
    else
        return n * fact(n-1)
}

// Đây là tail recursion vì chỉ cần gọi fact(n-1, acc*n)
// xong thì hàm sẽ kết thúc
function fact(n, acc) {
    if (n === 1)
        return acc
    else
        return fact(n-1, acc*n)
}
</code></pre>
<p>Bạn có thể tự tìm hiểu kĩ hơn tại sao khi đưa về tail recursion thì sẽ tối ưu hơn, nhưng để nói sơ qua thì bình thường khi bạn gọi đệ quy, những giá trị, ô nhớ các thứ ở hiện tại sẽ được đẩy lên call stack, cứ mỗi lần gọi đệ quy lồng nhau thì call stack sẽ càng ngày càng cao lên, bộ nhớ phình to ra, cho đến khi vượt quá call stack size thì chương trình trả về lỗi stack overflow. Tail recursion thì lại khác, vì đệ quy là câu lệnh được thực hiện cuối cùng nên compiler sẽ thoải mái giải phóng stack hiện tại vì nó chắc chắn stack hiện tại không cần dùng nữa, nên dù có gọi đệ quy vô hạn lần thì cũng không lo bị stack overflow.</p>
<p>Tiếp tục nhé, bây giờ để biến <span class="math inline">\(\operatorname{fib}(n)\)</span> thành tail recursion, ta lấy phương trình <span class="math inline">\((3)\)</span> đem biến đổi thử, và chúng ta muốn sau khi biến đổi xong thì vế phải phải có dạng giống na ná vế trái, từ đó ta có thể định nghĩa một hàm phụ <span class="math inline">\(F\)</span> nào đó sao cho vế trái và vế phải phụ thuộc vào nhau thông qua <span class="math inline">\(F\)</span>, kiểu như <span class="math inline">\(F(2n) = F(3n-1)\)</span> chẳng hạn. Rồi vậy ta thử cộng <span class="math inline">\(\operatorname{fib}(n+1)\)</span> vào hai vế xem sao:</p>
<p><span class="math display">\[\operatorname{fib}(n+1) + \operatorname{fib}(n+2) = \operatorname{fib}(n) + 2\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Hai vế khá giống nhau rồi đó, <span class="math inline">\(\operatorname{fib}(n+1)\)</span> (vế trái) tương ứng với <span class="math inline">\(\operatorname{fib}(n)\)</span> (vế phải) là ổn rồi nè, còn <span class="math inline">\(\operatorname{fib}(n+2)\)</span> (vế trái) tương ứng với <span class="math inline">\(\operatorname{fib}(n+1)\)</span> (vế phải) thì vẫn chưa ổn vì bị khác hệ số, để khắc phục chuyện này thì ta sẽ đưa ra một biến khác, gọi là biến <span class="math inline">\(b\)</span> đi. Giờ ta thử cộng <span class="math inline">\((b-1)\operatorname{fib}(n+2)\)</span> vào hai vế xem sao (mục đích cộng như vậy là để <span class="math inline">\(\operatorname{fib}(n+2)\)</span> có hệ số là <span class="math inline">\(b\)</span>):</p>
<p><span class="math display">\[\operatorname{fib}(n+1) + b\cdot \operatorname{fib}(n+2) = b\cdot \operatorname{fib}(n) + (b+1)\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Ta nhận thấy hệ số của <span class="math inline">\(\operatorname{fib}(n+1)\)</span> và <span class="math inline">\(\operatorname{fib}(n)\)</span> chưa giống nhau (bên là <span class="math inline">\(1\)</span>, bên là <span class="math inline">\(b\)</span>), nên là ta đưa thêm biến <span class="math inline">\(a\)</span> vào và làm tương tự, ta được:</p>
<p><span class="math display">\[a\cdot \operatorname{fib}(n+1) + b\cdot \operatorname{fib}(n+2) = b\cdot \operatorname{fib}(n) + (a+b)\cdot \operatorname{fib}(n + 1)\tag{4}
\]</span></p>
<p>Tuyệt vời ông mặt trời, hai bên có cùng một dạng rồi đó, bây giờ ta định nghĩa hàm phụ <span class="math inline">\(F\)</span> như sau:</p>
<p><span class="math display">\[F(a, b, n) = a\cdot \operatorname{fib}(n) + b\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Từ đó ta có thể biểu diễn hai vế của <span class="math inline">\((4)\)</span> dưới dạng:</p>
<p><span class="math display">\[F(a, b, n+1) = F(b, a+b, n) \tag{*}
\]</span></p>
<p>Ngoài ra dựa vào định nghĩa của <span class="math inline">\(F\)</span>, ta được:</p>
<p><span class="math display">\[F(a, b, 0) = a\cdot \operatorname{fib}(0) + b\cdot \operatorname{fib}(1) = a + b \tag{5}
\]</span></p>
<p>Hơn nữa:</p>
<p><span class="math display">\[\operatorname{fib}(n) = 1\cdot \operatorname{fib}(n) + 0\cdot \operatorname{fib}(n+1) = F(1, 0, n) \tag{6}
\]</span></p>
<p>Ta đã hoàn toàn có đủ nguyên liệu để triển khai thuật toán rồi đó, để ý:</p>
<ul>
<li><span class="math inline">\((6)\)</span> cho ta được định nghĩa tổng quát của <span class="math inline">\(\operatorname{fib}(n)\)</span> dựa trên hàm phụ <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((*)\)</span> cho ta công thức đệ quy của <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((5)\)</span> cho ta base case đệ quy của <span class="math inline">\(F\)</span>.</li>
</ul>
<p>Hy vọng tới đây mọi thứ make sense được với bạn, nếu lú thì cũng không sao cứ đọc lại nhé, mấy lần đầu mình đọc cũng lú 🙂 Giờ thì code thôi (2 code dưới này đều là của tác giả bài toán hết nha, không phải của tui):</p>
<pre><code class="language-python">def fib(n):

    def F(a, b, n):
        if n == 0: return a + b    # see (5) above
        return F(b, a + b, n - 1)  # see (*) above

    return F(1, 0, n)              # see (6) above
</code></pre>
<p>Tới đây là <span class="math inline">\(QED\)</span> rồi, nhưng nếu ngôn ngữ bạn dùng không hỗ trợ tối ưu đệ quy đuôi (<a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail call optimization</a>) thì bạn có thể implement theo dạng khử đệ quy như sau:</p>
<pre><code class="language-python">def fib(n):
    a, b = 1, 0                    # see (6) above
    while n > 0:
        a, b, n = b, a + b, n - 1  # see (*) above
    return a + b .                 # see (5) above
</code></pre>
<blockquote>
Đây là một sức mạnh khác của tail recursion, một khi bạn đã đưa hàm về tail recursion rồi thì việc khử đệ quy là vô cùng đơn giản.
</blockquote>
<p>Tuyệt dời, làm “tương tự” với hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> thôi nào 😉. Nếu đọc tới đây mà bạn đã có ý tưởng, hoặc muốn thử sức bản thân thì có thể pause lại. Thật ra theo tui thì một khi đã nắm được ý tưởng của phương pháp này rồi thì cũng không quá khó đâu.</p>
<h2>Giải quyết bài toán</h2>
<p>Nhắc lại định nghĩa của hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span>. Để cho <del>gõ đỡ mỏi tay</del> đơn giản thì tui đặt hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> là hàm <span class="math inline">\(f(n)\)</span> luôn nhé:</p>
<p><span class="math display">\[\begin{cases}
f(0) = 0 & (1)\\
f(1) = 1 & (2)\\
f(2n) = f(n) & (3)\\
f(2n + 1) = f(n) + f(n + 1) & (4)\\
\end{cases}
\]</span></p>
<p>Tương tự như ví dụ trên, từ định nghĩa ta sẽ cố gắng tìm phương trình nào đó sao cho hai vế có cùng dạng, rồi từ đó đặt hàm phụ. Lấy <span class="math inline">\((3)\)</span> và <span class="math inline">\((4)\)</span> cộng lại với nhau thử coi sao:</p>
<p><span class="math display">\[f(2n)+f(2n+1)=2f(n) + f(n+1)
\]</span></p>
<p>Thấy hai vế cũng na ná giống rồi nè, <span class="math inline">\(f(2n)\)</span> tương ứng với <span class="math inline">\(f(n)\)</span> và <span class="math inline">\(f(2n+1)\)</span> tương ứng với <span class="math inline">\(f(n+1)\)</span>. Bây giờ tìm cách cân bằng hệ số thôi. Cụ thể, ta sẽ đưa biến <span class="math inline">\(b\)</span> vào phương trình bằng cách cộng <span class="math inline">\((b-1)f(2n+1)\)</span> hai vế, ta được:</p>
<p><span class="math display">\[f(2n)+bf(2n+1)=(b+1)f(n) + bf(n+1)
\]</span></p>
<p>Tương tự, đưa biến <span class="math inline">\(a\)</span> vào phương trình:</p>
<p><span class="math display">\[af(2n)+bf(2n+1)=(a+b)f(n) + bf(n+1) \tag{5}
\]</span></p>
<p>Hai vế đã cùng dạng như mình ao ước rồi đó, giờ định nghĩa hàm phụ <span class="math inline">\(F\)</span> thôi:</p>
<p><span class="math display">\[F(a, b, n) = af(n) + bf(n+1)
\]</span></p>
<p>Từ đó ta biểu diễn <span class="math inline">\((5)\)</span> theo <span class="math inline">\(F\)</span> như sau:</p>
<p><span class="math display">\[F(a,b,2n) = F(a+b,b,n) \tag{*}
\]</span></p>
<p>Ngoài ra từ định nghĩa của <span class="math inline">\(F\)</span> suy ra được:</p>
<p><span class="math display">\[F(a,b,0) = af(0) + bf(1) = b \tag{6.1}
\]</span></p>
<p>Và:</p>
<p><span class="math display">\[F(a,b,1) = af(1) + bf(2) = a + b \tag{6.2}
\]</span></p>
<p>Hơn nữa:</p>
<p><span class="math display">\[f(n) = 1f(n) + 0f(n+1) = F(1,0,n) \tag{7}
\]</span></p>
<p>Ngừng lại một chút, tới đây ta vẫn chưa thể triển khai thành thuật toán hoàn chỉnh được, tại sao ư? Để ý <span class="math inline">\((*)\)</span> chỉ được định nghĩa với <span class="math inline">\(2n\)</span>, tức khi input là số chẵn, vậy còn lẻ thì sao? Đơn giản thôi, thế trường hợp input lẻ vào <span class="math inline">\(F\)</span> rồi biến đổi, tức là:</p>
<p><span class="math display">\[\begin{align*}
F(a,b,2n+1)
&= af(2n+1) + bf(n+1)\\
&= a[f(n) + f(n+1)] + bf(n+1)\\
&= af(n) + (a+b)f(n+1)\\
&= F(a,a+b,n) \tag{**}
\end{align*}
\]</span></p>
<p>Ta tổng hợp lại được như sau:</p>
<ul>
<li><span class="math inline">\((7)\)</span> cho ta định nghĩa tổng quát của <span class="math inline">\(f(n)\)</span> dựa trên <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((*)\)</span> cho ta công thức đệ quy của <span class="math inline">\(F\)</span> đối với trường hợp input chẵn, tương tự với <span class="math inline">\((**)\)</span> ở trường hợp input lẻ.</li>
<li><span class="math inline">\((6.1)\)</span> và <span class="math inline">\((6.2)\)</span> cho ta base case đệ quy của <span class="math inline">\(F\)</span>.</li>
</ul>
<p>Code thoai:</p>
<pre><code class="language-js">function fusc(n) {

    function F(a, b, k) {
        if (k === 0)  // See (6.1)
            return b
        else if (k === 1)  // See (6.2)
            return a + b
        else if (k % 2 === 0)  // See (*)
            return F(a+b, b, Math.round(k / 2))
        else  // See (**)
            return F(a, a+b, Math.round((k-1) / 2))
    }

    return F(1, 0, n)  // See (7)
}
</code></pre>
<p>Submit thử:<br>
<img src="https://i.imgur.com/yoKDKTn.png" alt="submit-code-img"><br>
Ngon lành chứ hả, bonus cho mấy bạn thêm code Haskell nè:</p>
<pre><code class="language-haskell">fusc :: Integer -> Integer
fusc n = aux 1 0 n
  where
    aux _ b 0 = b
    aux a b 1 = a+b
    aux a b n
      | even n = aux (a+b) b (n `div` 2)
      | otherwise = aux a (a+b) ((n-1) `div` 2)
</code></pre>
<p>Tui biết có một số bạn đọc tới đây rồi thì ngứa lắm, có thể bạn sẽ thắc mắc tại sao không dùng quy hoạch động? Thì đầu tiên là tui đang muốn nhấn mạnh về phương pháp này, nên quy hoạch động không nằm trong khuôn khổ của bài viết. Thứ 2 là quy hoạch động thật ra cũng không hiệu quả bằng đâu, tui cũng có thử implement quy hoạch động xong submit thử rồi nhưng nó tốn quá nhiều bộ nhớ, codewars không accept (người ta tính hết rồi ^^).</p>
<h2>Góc nhìn của tui về phương pháp này</h2>
<p>Trong pure functional programming language (FP) như Haskell thì không có vòng lặp cho bạn dùng, thay vào đó nếu bạn muốn lặp thì bạn phải xây dựng đệ quy. Mà thực tế có những tính năng bạn cần lặp vô hạn hoặc lặp rất nhiều lần, để không bị stack overflow trên những tính năng đó thì họ phải hướng tới tail recursion. Vậy làm sao để xây dựng tail recursion? ừa thì linh cảm, tâm linh là chính thôi, lấy ví dụ cho hàm tính giai thừa:</p>
<pre><code class="language-js">// Đệ quy thông thường
function fact(n) {
    if (n === 1)
        return 1
    else
        return n * fact(n-1)
}

// Tail recursion
function fact(n, acc) {
    if (n === 1)
        return acc
    else
        return fact(n-1, acc*n)
}
fact(10, 1) // tính 10!
</code></pre>
<p>Hàm đệ quy thông thường thì đơn giản rồi mình sẽ không nhắc tới nhé. Còn phần tail recursion ở dưới mình có thể hiểu là ta cần 1 biến nhân dồn kết quả lại, gọi là <code>acc</code> (accumulator). <code>acc</code> có giá trị ban đầu là 1, mỗi lần gọi đệ quy thì ta nhân <code>n</code> vô <code>acc</code>, đồng thời giảm <code>n</code> xuống một đơn vị, rồi truyền vào đệ quy kế tiếp. Cứ truyền xuống như vậy, lúc này bạn sẽ thấy <code>acc</code> mang giá trị của tích <code>n(n-1)(n-2)...</code> và cũng là kết quả mình cần tìm khi <code>n</code> giảm xuống 1.</p>
<p>Đây cũng là pattern chung trong phương pháp tìm tail recursion, ta sẽ có biến tích luỹ <code>acc</code> là tham số được truyền dần xuống, và nó sẽ đem theo kết quả cho đến khi chạm base case. Nhưng ta có thể thấy pattern trên chỉ do mình cảm giác và tưởng tượng (aka tâm linh) chứ không được chứng minh rõ ràng, và ban đầu mình cũng nghĩ mấy thứ này không thể chứng minh được cho đến khi gặp bài toán xịn xò mà mình đã giải quyết bên trên.</p>
<blockquote>
Góc bài tập về nhà: Bạn có thể thử suy nghĩ cách chứng minh định nghĩa hàm fact(n, acc) bên trên là đúng dựa trên phương pháp chặt chẽ của bài viết. Và xây dựng lại tail recursion cho fib(n) dựa trên phương pháp tâm linh này, bạn sẽ bất ngờ vì nó cho cùng một kết quả đó.
</blockquote>
<p>Cảm ơn mấy bạn đã đọc hết đến đây (hoặc là do bạn lướt xuống và gặp được dòng này). Đây là bài viết đầu tiên trên blog của tui, tui xin nhận mọi ý kiến đóng góp, nhưng nếu bạn có ý định ném đá thì nên cân nhắc lời lẽ phù hợp với trái tim mỏng manh của tác giả 😢.</p>
</div> <div class="post-hashtag-container"><div class="tag-title"><p>Tags:</p></div> <div><a href="/?tags=algorithm" class="hashtag" data-v-578e9d56>
        #algorithm
    </a><a href="/?tags=recursion" class="hashtag" data-v-578e9d56>
        #recursion
    </a><a href="/?tags=functional-programming" class="hashtag" data-v-578e9d56>
        #functional-programming
    </a></div></div></div> <div class="comment-section"><div class="comment-divider"></div> <div class="comment-input-container"><!----> <div class="comment-login"><p>Tham gia bình luận với</p> <button class="comment-login-site"><i class="fab fa-github"></i></button> <p>hoặc</p> <button class="comment-login-site"><i class="fab fa-google"></i></button></div></div> <div class="comment-list"></div></div></div> <div id="footer"><p id="footer-text">
        Created by
            <a href="https://www.facebook.com/100007015541619" target="_blank"><span></span></a>
        with
        <span id="footer-emoji-heart" class="fas fa-heart"></span>
        and some 
        <span id="footer-emoji-tear" class="fas fa-tint"></span></p></div></article></div></div></div><script defer src="/_nuxt/static/1685628949/posts/interesting-tail-call-elimination-problem/state.js"></script><script src="/_nuxt/2d9de3f.js" defer></script><script src="/_nuxt/a041fa1.js" defer></script><script src="/_nuxt/2724976.js" defer></script><script src="/_nuxt/2d0a0ae.js" defer></script><script src="/_nuxt/8538b13.js" defer></script><script src="/_nuxt/0a5dc33.js" defer></script><script src="/_nuxt/761ab04.js" defer></script>
  </body>
</html>
