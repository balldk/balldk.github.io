<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="icon" href="../../favicon.ico" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	
		<link href="../../_app/immutable/assets/0.B702pQFm.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/11.q_FjF5fW.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/Proof.BvBuTdLQ.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.CO7HKZ9Y.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DmyebKyi.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/g0HKWCZd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DMY9xPNz.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/CaUiJ1m3.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.BiV0-Ugg.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C1FmrZbK.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BntSvHci.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BOkZfMn7.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DX7Grmzp.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Ciu5Zpq_.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DREvKzIH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BOpPzQmY.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/pIfFs6sh.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.BPl_IXjk.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DF4yiWGH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/6Y8AOO_8.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BwA_N50a.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/3.Dd9M1NhI.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/11.DusWBAeY.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Ba4l0lZH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BbQpLqOI.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Bk14xdPL.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DA6iSUxa.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/K9tT9GRH.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/BjlpqrTy.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/DRP0DMUf.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/tWk0kTU-.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C8x-1e-_.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/C9B-BX1y.js"><!--[--><!--]--><title>VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt</title>
</head>

<body data-sveltekit-preload-data="hover">
	<div style="display: contents"><!--[--><!--[--><!----><!--[--><!----><!----><div class="bg-background h-screen"><picture><source srcset="/_app/immutable/assets/grapevine.5sPCc6qf.avif 1x, /_app/immutable/assets/grapevine.W8CN0imf.avif 2x" type="image/avif"><source srcset="/_app/immutable/assets/grapevine.Czvk42U4.webp 1x, /_app/immutable/assets/grapevine.sRuPh4UC.webp 2x" type="image/webp"><source srcset="/_app/immutable/assets/grapevine.C_11B9ew.png 1x, /_app/immutable/assets/grapevine.D5jdj8Mv.png 2x" type="image/png"><img src="/_app/immutable/assets/grapevine.D5jdj8Mv.png" alt="" class="mx-auto mb-0 mt-[-4.5em] z-[-1] h-52 w-auto" width="800" height="541"></picture> <!----><article class="blog-post lg:mx-auto lg:w-[46em] md:mx-[3em] mx-[1em] text-justify opacity-0"><!--[--><div class="grid grid-cols-3 text-sm border-solid border-t-2 border-black"><div>No. 01</div> <!--[--><div class="text-center">Posted in 25 February 2023</div><!--]--> <div class="text-right">12 min read</div></div> <div class="mb-6 title-container py-3 border-solid border-y-2 border-black"><h1 class="text-center font-bold text-4xl">VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt</h1></div><!--]--> <content><p>VanVo (Văn Vở) là ngôn ngữ lập trình được thiết kế với cú pháp thuần Việt, nhưng không chỉ đơn giản là dịch lại một cách gượng gạo từ các ngôn ngữ khác, mình cố gắng để thiết kế một ngôn ngữ sao cho các câu lệnh trông tự nhiên như tiếng Việt nhất có thể, thuận tiện cho người Việt nhất có thể. Điển hình là bạn có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</p> <p>Ngôn ngữ sẽ có hơi thiên hướng toán học, những bạn học toán có thể sẽ cảm thấy quen thuộc hơn, vì mình định hướng ngôn ngữ được sử dụng như một CAS (Computer Algebra System). Tuy nhiên VanVo vẫn có thể dùng như một ngôn ngữ đa mục đích (General-purpose language) thông thường.</p> <h2>Điểm qua một số tính năng của VanVo</h2> <ul><li><p>Hỗ trợ những câu lệnh rẽ nhánh, cấu trúc lặp, cấu trúc dữ liệu và phép toán cơ bản.</p></li> <li><p>Hỗ trợ phân số và số phức.</p></li> <li><p>Có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</p></li> <li><p>Không cần <code>;</code> ở cuối mỗi câu lệnh, và các khối lệnh sẽ được xác định bởi mức thụt dòng (indent level) như Python.</p></li> <li><p>Phép nhân giữa hằng số, biến và mở ngoặc có thể lược bỏ, ví dụ <code>2x(x-1)</code> sẽ tương đương với <code>2*x*(x-1)</code>.</p></li> <li><p>List comprehension như <code>{ n*m | n thuộc [1..10], m thuộc [1..10], n != m }</code></p></li> <li><p>Lazy evaluation.</p></li> <li><p>Các thao tác và phép toán trên tập hợp như hội, giao, hiệu, tích Descartes.</p></li> <li><p>Gạch chân chính xác vị trí có lỗi khi chạy chương trình.</p></li></ul> <h2>Cài đặt</h2> <p>Nếu bạn đã tải <a href="https://go.dev/" rel="nofollow" target="_blank">Go</a> thì cách đơn giản nhất để cài đặt là clone và build trực tiếp từ source như sau</p> <pre class="language-bash"><!----><code class="language-bash"><span class="token function">git</span> clone https://github.com/balldk/vanvo
<span class="token builtin class-name">cd</span> vanvo
go <span class="token function">install</span> <span class="token builtin class-name">.</span></code><!----></pre> <p>Ngoài ra bạn có thể tải file thực thi tại đây <a href="https://github.com/balldk/vanvo/releases/tag/v0.1.0" rel="nofollow" target="_blank">Releases v0.1.0</a>.</p> <p><strong>Cài đặt language support:</strong> Để ngôn ngữ có syntax highlight và snippets trên VSCode thì bạn hãy qua đây cài thêm extension nhé: <a href="https://github.com/balldk/vscode-vanvo" rel="nofollow" target="_blank">github.com/balldk/vscode-vanvo</a>.</p> <p>Để chạy chương trình ta dùng lệnh</p> <pre class="language-vanvo"><!----><code class="language-vanvo">vanvo program.vv</code><!----></pre> <p>Trong đó <code>program.vv</code> là file chứa nội dung code. Nói chung file extension của VanVo là <code>.vv</code>.</p> <h2>Một số ví dụ minh họa</h2> <p><strong>Ví dụ 1:</strong> Xét tính chia hết của n cho 2 và 3, với n là các số nguyên trong khoảng <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span><!----></span></p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = [1..100]

với mỗi n thuộc A:
	nếu n % 2 == 0:
		xuất n, &quot;chia hết cho 2&quot;
	còn nếu n % 3 == 0:
		xuất n, &quot;chia hết cho 3&quot;
	còn không:
		xuất n, &quot;không chia hết cho cả 2 và 3&quot;</code><!----></pre> <p><strong>Ví dụ 2:</strong> Tính giá trị của hàm hợp, với <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi mathvariant="normal">.</mi><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f.g)(x) = f(g(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span><!----></span></p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho f(x) = 2x(x^2 - 2x)(3x - 5)
cho g(x) = 5x

cho a = 5
xuất f.g(a)</code><!----></pre> <p><code>2x(x^2 - 2x)(3x - 5)</code> là cách viết ngắn gọn hơn của <code>2*x*(x^2 - 2*x)*(3*x - 5)</code>.</p> <p><strong>Ví dụ 3:</strong> Sử dụng list comprehension để định nghĩa mảng vô hạn các phần tử, với <code>fib[i]</code> là phần tử thứ <code>i</code> trong dãy fibonacci</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho fib = &#123;0, 1, 1&#125; + &#123; fib[n-1] + fib[n-2] | n thuộc [3..] &#125;

với mỗi n thuộc fib:
    xuất n</code><!----></pre> <p>List comprehension có tính “lazy”, tức là chỉ khi ta cần dùng phần tử nào trong mảng thì phần tử đó mới được tính ra, do đó ta có thể dễ dàng định nghĩa ra mảng vô hạn phần tử trong VanVo.</p> <p><strong>Ví dụ 4:</strong> Hệ thống báo lỗi của chương trình</p> <p><img src="https://i.imgur.com/49okCkK.png" alt="screenshot_error"></p> <h2>Cú pháp</h2> <h3>Quy định đặt tên và từ khóa</h3> <p>Tên định danh là tên được bạn đặt cho biến và hàm trong chương trình, VanVo bao gồm các quy tắc đặt tên định danh như sau:</p> <ul><li>Có thể chứa các kí tự <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>_</code> và toàn bộ bảng chữ cái cũng như dấu trong tiếng Việt.</li> <li>Không được bắt đầu bằng một chữ số.</li> <li>Khác với hầu hết các ngôn ngữ khác, VanVo cho phép bạn đặt tên định danh với khoảng trắng, nhưng có một lưu ý là khoảng trắng giữa các từ không quan trọng, ví dụ <code>nguyên tố</code> và <code>nguyên   tố </code> là hai tên định danh giống nhau.</li> <li>Phân biệt hoa thường (case sensitive).</li> <li>Không được đặt tên định danh trùng với từ khóa.</li></ul> <p>Danh sách các từ khóa trong VanVo:</p> <p><code>cho</code>, <code>thuộc</code>, <code>và</code>, <code>hay</code>, <code>với</code>, <code>với mỗi</code>, <code>nếu</code>, <code>còn nếu</code>, <code>còn không</code>, <code>đúng</code>, <code>sai</code>, <code>nhập</code>, <code>xuất</code></p> <p><strong>Note:</strong> Bạn có thể viết các từ khóa không dấu, ví dụ <code>neu</code>, <code>voi</code> là các từ khóa hợp lệ. Tuy nhiên bạn chỉ có thể viết đầy đủ dấu hoặc là viết không dấu hoàn toàn, ví dụ <code>đung</code> không phải là một từ khóa hợp lệ vì thiếu dấu sắc.</p> <h3>Khai báo biến</h3> <p>Biến được định nghĩa thông qua từ khóa <code>cho</code>, với cấu trúc như sau</p> <pre class="language-bnf"><!----><code class="language-bnf">cho <span class="token rule"><span class="token punctuation">&lt;</span>tên biến<span class="token punctuation">></span></span> = <span class="token rule"><span class="token punctuation">&lt;</span>biểu thức<span class="token punctuation">></span></span></code><!----></pre> <p>Ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho x = 10.2
cho ngày sinh = 15</code><!----></pre> <p>Một số hằng số được định nghĩa sẵn</p> <pre class="language-vanvo"><!----><code class="language-vanvo">xuất Pi // 3.14159...
xuất E  // 2.71828...</code><!----></pre> <h3>Khai báo hàm</h3> <p>Khai báo hàm tương đối giống với khai báo biến</p> <pre class="language-bnf"><!----><code class="language-bnf">cho <span class="token rule"><span class="token punctuation">&lt;</span>tên hàm<span class="token punctuation">></span></span><span class="token operator">(</span><span class="token rule"><span class="token punctuation">&lt;</span>danh sách các tham số<span class="token punctuation">></span></span><span class="token operator">)</span> = <span class="token rule"><span class="token punctuation">&lt;</span>biểu thức<span class="token punctuation">></span></span></code><!----></pre> <p>Ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho f(x,y,z) = 2x(x^2 - 2x + 1) - y^z
xuất f(100, 5, 3)</code><!----></pre> <p>Ở ví dụ trên, hàm chỉ được định nghĩa ngắn gọn trong một hàng, để viết một số hàm phức tạp, cần thực hiện nhiều câu lệnh hơn, ta có thể dùng “Biểu thức nhóm”</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho f(x) = (cho a = 5; cho b = 6; a+b+x)
xuất f(2) // 13</code><!----></pre> <p>Biểu thức cuối cùng trong biểu thức nhóm sẽ là giá trị trả về cho toàn bộ biểu thức, ở ví dụ trên <code>a+b+x = 5+6+2 = 13</code> là giá trị của <code>f(2)</code></p> <p>Trên thực tế ta sẽ xuống dòng tách các câu lệnh trong biểu thức nhóm</p> <pre class="language-vanvo"><!----><code class="language-vanvo">// Trả về đúng, nếu n là số chẵn, sai nếu n là số lẻ
cho là chẵn(n) = (
	cho two = 2
	nếu n % two == 0:
		=&gt; đúng
	sai
)</code><!----></pre> <p>Dấu suy ra <code>=></code> có ý nghĩa tương đương với câu lệnh <code>return</code> ở những ngôn ngữ khác, khi gặp <code>=></code> thì biểu thức nhóm sẽ kết thúc và trả về giá trị cho biểu thức</p> <p>Một số hàm được định nghĩa sẵn</p> <pre class="language-vanvo"><!----><code class="language-vanvo">xuất cos(Pi)  // -1
xuất sin(Pi)  // 0
xuất tan(Pi)  // 0
xuất E^ln(2)  // 2</code><!----></pre> <h3>Các kiểu dữ liệu cơ bản</h3> <pre class="language-vanvo"><!----><code class="language-vanvo">// Số nguyên
15
// số thực
3.14
// Phân số
3/14
// Số phức
3/2 - 2I
// Logic
đúng
sai</code><!----></pre> <h3>Phép toán</h3> <h4>Số học</h4> <pre class="language-vanvo"><!----><code class="language-vanvo">cho a = 4
cho b = 5/2

xuất a + b  // 13/2
xuất a - b  // 3/2
xuất a * b  // 10
xuất a / b  // 8/5
xuất a ^ b  // 32
xuất a % 7  // 4</code><!----></pre> <h4>Logic</h4> <pre class="language-vanvo"><!----><code class="language-vanvo">xuất 1 == 2  // sai
xuất 1 != 2  // đúng
xuất 1 &lt; 1   // sai
xuất 1 &lt;= 1  // đúng
xuất 1 &gt; 1   // sai
xuất 1 &gt;= 1  // đúng

xuất đúng và sai  // sai
xuất đúng hay sai // đúng</code><!----></pre> <h4>Toán tử ba ngôi</h4> <p>Cấu trúc của toán tử ba ngôi</p> <pre class="language-bnf"><!----><code class="language-bnf"><span class="token rule"><span class="token punctuation">&lt;</span>biểu thức 1<span class="token punctuation">></span></span> nếu <span class="token rule"><span class="token punctuation">&lt;</span>điều kiện<span class="token punctuation">></span></span> còn không <span class="token rule"><span class="token punctuation">&lt;</span>biểu thức 2<span class="token punctuation">></span></span></code><!----></pre> <p>Nếu <code>&lt;điều kiện></code> thỏa thì toán tử ba ngồi sẽ trả về giá trị của <code>&lt;biểu thức 1></code>, còn không thì trả về giá trị của <code>&lt;biểu thức 2</code>>. Ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho gtln(a, b) = a nếu a &gt; b còn không b
xuất gtln(2, 3)  // 3</code><!----></pre> <h3>Câu lệnh điều kiện</h3> <p>Câu lệnh điều kiện có cấu trúc như sau</p> <pre class="language-bnf"><!----><code class="language-bnf">nếu <span class="token rule"><span class="token punctuation">&lt;</span>điều kiện 1<span class="token punctuation">></span></span>:
	<span class="token operator">...</span>
còn nếu <span class="token rule"><span class="token punctuation">&lt;</span>điều kiện 2<span class="token punctuation">></span></span>:
	<span class="token operator">...</span>
còn không:
	<span class="token operator">...</span></code><!----></pre> <p><code>...</code> ở đây là khối lệnh, một khối lệnh được xác định bởi mức thụt dòng (indent level) của đoạn code. Không như Python, ở trong VanVo thì indent size được cố định là 4, tab cũng được chương trình mặc định hiểu là 4 spaces.</p> <p>Ví dụ: xác định <code>n</code> là âm, dương hay 0</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho n = 100

nếu n &lt; 0:
	xuất n, &quot;là số âm&quot;
còn nếu n &gt; 0:
	xuất n, &quot;là số dương&quot;
còn không:
	xuất n, &quot;là 0&quot;</code><!----></pre> <h3>Cấu trúc lặp</h3> <p>Trong VanVo có hai cấu trúc lặp là <code>với</code> và <code>với mỗi</code>, <code>với</code> có ý nghĩa tương đương với <code>while</code> ở những ngôn ngữ khác, còn <code>với mỗi</code> sẽ ý nghĩa tương tự như vòng lặp <code>for</code> nhưng không giống hoàn toàn mà sẽ có những đặc trưng riêng.</p> <h4>Với</h4> <p><code>với</code> có cấu trúc như sau</p> <pre class="language-bnf"><!----><code class="language-bnf">với <span class="token rule"><span class="token punctuation">&lt;</span>danh sách điều kiện<span class="token punctuation">></span></span>:
	<span class="token operator">...</span></code><!----></pre> <p>Vòng lặp sẽ được thực hiện cho đến khi một trong các điều kiện của <code>&lt;danh sách điều kiện></code> không thỏa thì vòng lặp dừng lại.</p> <p>Ví dụ: xuất ra các số trong khoảng <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">)</span></span></span></span><!----></span></p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho i = 0
với 0 &lt;= i, i &lt; 100:
	xuất i
	i = i + 1</code><!----></pre> <p>Điều kiện <code>0 &lt;= i, i &lt; 100</code> tương đương với <code>0 &lt;= i và i &lt; 100</code>. Ngoài ra bạn có thể sử dụng chaining comparison operator <code>0 &lt;= i &lt; 100</code> để ngắn gọn hơn.</p> <h4>Với mỗi</h4> <p><code>với mỗi</code> có cấu trúc như sau</p> <pre class="language-bnf"><!----><code class="language-bnf">với mỗi <span class="token rule"><span class="token punctuation">&lt;</span>biến<span class="token punctuation">></span></span> thuộc <span class="token rule"><span class="token punctuation">&lt;</span>tập đếm được<span class="token punctuation">></span></span>, <span class="token rule"><span class="token punctuation">&lt;</span>ràng buộc<span class="token punctuation">></span></span>,<span class="token operator">...</span>:
	<span class="token operator">...</span></code><!----></pre> <p>Hãy thử nhìn vào ví dụ trước nhé, chương trình sau sẽ xuất ra các số chẵn trong khoảng <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span><!----></span></p> <pre class="language-vanvo"><!----><code class="language-vanvo">với mỗi n thuộc [1..100], x % 2 == 0:
	xuất n

// Output:
2
4
6
...
100</code><!----></pre> <p>Ở chương trình trên, <code>n</code> lặp qua từng phần tử trong <code>[1..100]</code>, với <code>[1..100]</code> là tập các số nguyên trong khoảng từ 1 đến 100. Nếu <code>n</code> thỏa mọi ràng buộc được cho thì khối lệnh bên trong sẽ được thực hiện (trong trường hợp này thì ràng buộc là <code>n % 2 == 0</code>). Dĩ nhiên không phải tập hợp nào cũng có thể lặp qua được, phần tiếp theo sẽ giải thích vấn đề này chi tiết hơn.</p> <p>Bạn có thể lặp qua nhiều tập và có nhiều ràng buộc cùng một lúc, lấy ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">với mỗi n thuộc [1..5], m thuộc [3..5], n % 2 == 0, m % 2 == 1:
	xuất n, m

// Output:
2 3
2 5
4 3
4 5</code><!----></pre> <h3>Tập hợp</h3> <p>Ban đầu khi mình phát thảo ý tưởng cho ngôn ngữ này thì mình lấy tập hợp, các phép toán và mệnh đề trên tập hợp làm tư tưởng chính. Nhưng càng về sau thì mình nhận ra là để xây dựng khái niệm tập hợp chuẩn thì tương đối không hiệu quả, và hầu hết các trường hợp thì mảng vẫn hữu dụng hơn, cho nên khái niệm mảng và tập hợp trong VanVo mình sẽ dùng trùng lặp nhau, bạn đọc nên hiểu hai khái niệm này trong VanVo là một, nhưng chúng không tương đương với khái niệm tập hợp thông thường.</p> <p>Trong VanVo có những tập hợp được gọi là <strong>Tập đếm được</strong>, bạn có thể truy cập chỉ số (indexing) và lặp qua tập đếm được, những tập còn lại được gọi là <strong>Tập không đếm được</strong>. Sau đây là các loại tập hợp hiện có trong VanVo.</p> <h4>Khoảng Thực (Real interval)</h4> <p>Khoảng thực <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span><!----></span> là tập các số thực <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><!----></span> sao cho <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq x \leq b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span><!----></span>, bạn có thể dùng toán tử <code>thuộc</code> để xét xem một giá trị <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span><!----></span> có thuộc vào một tập hay không, lấy ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = [0,5]

xuất 2 thuộc A    // đúng
xuất 5 thuộc A    // đúng
xuất -1 thuộc A   // sai
xuất I thuộc A    // sai</code><!----></pre> <p>Khoảng thực là Tập không đếm được.</p> <h4>Khoảng đều</h4> <p>Khoảng đều <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a..b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mord">..</span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span><!----></span> là tập các số <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span><!----></span> sao cho <span class="math math-inline"><!----><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leq n \leq b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span><!----></span>, và các phần tử liên tiếp cách nhau đúng một đơn vị, lấy ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho a = 1.2
cho b = 5
cho A = [a..b]

với mỗi x thuộc A:
	xuất x

xuất b thuộc A

// Output:
1.2
2.2
3.2
4.2
sai</code><!----></pre> <p>Từ ví dụ trên ta có thể nhận thấy Khoảng đều là một Tập đếm được.</p> <p>Bạn có thể đặt bước nhảy (step) cho một Khoảng với cú pháp <code>[a..b, step]</code>, ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">với mỗi n thuộc [0..4, 2]:
	xuất n

// Output:
0
2
4</code><!----></pre> <h4>Danh sách (List)</h4> <p>Danh sách sẽ tương đối giống mảng thông thường ở những ngôn ngữ khác, với cú pháp <code>{a, b, c, ...}</code>, ví dụ</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = &#123;1, 2, &quot;hello&quot;, đúng&#125;

với mỗi phần tử thuộc A:
	xuất phần tử

// Output:
1
2
&quot;hello&quot;
đúng</code><!----></pre> <h4>List comprehension</h4> <p>Mình cũng không rõ phải dịch khái niệm này ra như thế nào, nhưng riêng trong VanVo thì list comprehension sẽ có cấu trúc giống y như cách chúng ta biểu diễn tập hợp trong toán</p> <pre class="language-bnf"><!----><code class="language-bnf"><span class="token operator">&#123;</span> <span class="token rule"><span class="token punctuation">&lt;</span>biểu thức<span class="token punctuation">></span></span> <span class="token operator">|</span> <span class="token rule"><span class="token punctuation">&lt;</span>biến<span class="token punctuation">></span></span> thuộc <span class="token rule"><span class="token punctuation">&lt;</span>tập đếm được<span class="token punctuation">></span></span>, <span class="token rule"><span class="token punctuation">&lt;</span>ràng buộc<span class="token punctuation">></span></span> <span class="token operator">&#125;</span></code><!----></pre> <p>Có thể thấy cấu trúc của list comprehension và vòng lặp “với mỗi” có sự tương đồng nhất định, vì chúng thật sự có cơ chế gần giống nhau, ta có thể hiểu <code>&lt;biểu thức></code> ở đây là phần thân của vòng lặp, và giá trị của <code>&lt;biểu thức></code> sẽ là từng phần tử trong tập trên.</p> <p>Ví dụ: Xây dựng tập các số nguyên dương chẵn</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = &#123; n | n thuộc [1..], n % 2 == 0 &#125;</code><!----></pre> <p>Hoặc đơn giản hơn là</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = &#123; 2n | n thuộc [1..] &#125;</code><!----></pre> <p>Bạn có thể nghi ngờ rằng khi chạy câu lệnh trên thì chương trình bị vướng vào vòng lặp vô hạn và không thể chạy tiếp những câu lệnh khác, nhưng thực tế thì chương trình vẫn tiếp tục chạy những câu lệnh tiếp theo, bạn có thể thao tác trên <code>A</code>, hay lấy ra bất kì phần tử nào trong tập <code>A</code> đó mà bạn muốn. Lý do ta có thể làm được việc này là vì VanVo có hỗ trợ lazy evaluation cho list comprehension, chỉ khi bạn cần phần tử nào thì chương trình mới tính ra phần tử đó (và các phần tử trước) rồi lưu lại. Vì vậy ta có thể dễ dàng định nghĩa ra mảng vô hạn các phần tử trong VanVo.</p> <h4>Các thao tác và phép toán trên tập hợp</h4> <p><strong>Lực lượng (#)</strong>: Hiện tại chỉ có thể lấy lực lượng (số phần tử) trên Tập đếm được</p> <pre class="language-undefined"><!----><code class="language-undefined">cho A = [1..100, 2]
cho B = &#123;3, 5, 7&#125;

#A      // 50
#B      // 3
#(A-B)  // 50</code><!----></pre> <p><strong>Chỉ số:</strong> Tương tự, chỉ có Tập đếm được mới có chỉ số</p> <pre class="language-undefined"><!----><code class="language-undefined">cho A = [1..100, 2]
cho fib = &#123;0, 1, 1&#125; + &#123; fib[n-1] + fib[n-2] | n thuoc [3..] &#125;

A[1]     // 3
fib[50]  // 12586269025</code><!----></pre> <p><strong>Phép hội (+)</strong>: Đối với trường hợp lấy hội 2 Tập đếm được thì ta hiểu đây là phép hợp nối mảng sẽ chính xác hơn</p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = &#123;1, 2&#125; + [6..10]  // &#123;1, 2, 6, 7, 8, 9, 10&#125;
cho B = &#123;1, 2&#125; + [6, 10]  // B là Tập không đếm được

8.2 thuộc B  // đúng</code><!----></pre> <p><strong>Phép hiệu (-)</strong></p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = [1..9] - [4, 6]  // &#123;1, 2, 3, 7, 8, 9&#125;
cho B = [1, 9] - [4, 6]  // B là Tập không đếm được

7 thuộc B  // đúng</code><!----></pre> <p><strong>Tích Descartes (*)</strong></p> <pre class="language-vanvo"><!----><code class="language-vanvo">cho A = [1..3]
cho B = [1..3]

A*B
// &#123; &#123;1, 1&#125;, &#123;1, 2&#125;, &#123;1, 3&#125;,
//   &#123;2, 1&#125;, &#123;2, 2&#125;, &#123;2, 3&#125;,
//   &#123;3, 1&#125;, &#123;3, 2&#125;, &#123;3, 3&#125; &#125;</code><!----></pre> <h2>Túm cái váy</h2> <p>Hiện tại ngôn ngữ vẫn còn sơ khai và sẽ còn nhiều thay đổi trong thời gian tới, nhìn chung thì dự án này cũng chỉ là sở thích cá nhân thôi, mình không có ý định tạo ra với mục đích thay thế bất kì ngôn ngữ nào trên thị trường cả nên các bạn có ý kiến đóng góp hay ý tưởng gì thì cồm men bên dưới nhẹ nhàng hoặc có thể tạo issue trên github nhé.</p><!----></content> <picture><source srcset="/_app/immutable/assets/ornament-line.MovhZPUm.avif 1x, /_app/immutable/assets/ornament-line.DLLmNnM0.avif 2x" type="image/avif"><source srcset="/_app/immutable/assets/ornament-line.DRxdZNih.webp 1x, /_app/immutable/assets/ornament-line.DiJdCD7C.webp 2x" type="image/webp"><source srcset="/_app/immutable/assets/ornament-line.DSZROH0z.png 1x, /_app/immutable/assets/ornament-line.2rgAX8N4.png 2x" type="image/png"><img src="/_app/immutable/assets/ornament-line.2rgAX8N4.png" alt="" class="mx-auto mt-14 h-8 w-full" width="1904" height="125"></picture></article> <div class="text-beige text-sm text-center w-full py-2 mt-20"><p class="inline">Created by <a href="https://fb.com/nddkhoaaa" target="_blank" class="m-[3px] text-[1.1em]"><!----><math><mover><mi>K</mi><mo stretchy="false" style="transform:scale(0.75) translate(10%, 30%);">→</mo></mover></math><!----></a> with 🤍 and 💧</p></div><!----><!----></div><!----><!----><!----><!--]--><!----><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_hgy331 = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../_app/immutable/entry/start.CO7HKZ9Y.js"),
						import("../../_app/immutable/entry/app.BiV0-Ugg.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3, 11],
							data: [null,null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
</body>

</html>