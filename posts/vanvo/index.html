<!doctype html>
<html data-n-head-ssr lang="vi" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22vi%22%7D%7D">
  <head>
    <meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="og:image" property="og:image" content="https://balldk.github.io/thumbnail.png"><meta data-n-head="ssr" data-hid="og:site_name" property="og:site_name" content="Góc nhỏ của K"><meta data-n-head="ssr" data-hid="description" name="description" content="Tất tần tật về ngôn ngữ lập trình VanVo (Văn Vở)."><meta data-n-head="ssr" data-hid="og:title" property="og:title" content="VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt | Góc nhỏ của K"><meta data-n-head="ssr" data-hid="og:description" property="og:description" content="Tất tần tật về ngôn ngữ lập trình VanVo (Văn Vở)."><meta data-n-head="ssr" data-hid="keywords" name="keywords" content="project"><meta data-n-head="ssr" data-hid="og:type" property="og:type" content="article"><title>VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt | Góc nhỏ của K</title><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.svg"><link data-n-head="ssr" rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous"><link data-n-head="ssr" rel="preconnect" href="https://fonts.googleapis.com"><link data-n-head="ssr" rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Signika:wght@300;400;500;600;700&display=swap"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap"><link data-n-head="ssr" rel="stylesheet" href='https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"'><link data-n-head="ssr" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous"><script data-n-head="ssr" async src="https://www.googletagmanager.com/gtag/js?id=G-SH612LCBTQ"></script><link rel="preload" href="/_nuxt/3b3cbff.js" as="script"><link rel="preload" href="/_nuxt/8538b13.js" as="script"><link rel="preload" href="/_nuxt/css/04e2415.css" as="style"><link rel="preload" href="/_nuxt/982a32e.js" as="script"><link rel="preload" href="/_nuxt/css/053bb57.css" as="style"><link rel="preload" href="/_nuxt/edb7dc6.js" as="script"><link rel="preload" href="/_nuxt/css/cf16f95.css" as="style"><link rel="preload" href="/_nuxt/a552c39.js" as="script"><link rel="preload" href="/_nuxt/2724976.js" as="script"><link rel="preload" href="/_nuxt/2d0a0ae.js" as="script"><link rel="stylesheet" href="/_nuxt/css/04e2415.css"><link rel="stylesheet" href="/_nuxt/css/053bb57.css"><link rel="stylesheet" href="/_nuxt/css/cf16f95.css"><link rel="preload" href="/_nuxt/static/1686154158/posts/vanvo/state.js" as="script"><link rel="preload" href="/_nuxt/static/1686154158/posts/vanvo/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1686154158/manifest.js" as="script">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><article><div class="head-bar"><a href="/" class="post-logo-container nuxt-link-active"><div class="logo"></div></a></div> <div class="post-container"><!----> <div class="post-content-container"><div class="post-header"><h1 class="post-title">VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt</h1> <p class="post-info"><i class="far fa-edit"></i> Đăng vào 19-8-2022</p> <p class="post-info"><i class="far fa-clock"></i> 12 phút đọc</p> <p class="post-info"><i class="fas fa-comment-alt"></i> 2 bình luận
        </p></div> <div class="post-content"><p>VanVo (Văn Vở) là ngôn ngữ lập trình được thiết kế với cú pháp thuần Việt, nhưng không chỉ đơn giản là dịch lại một cách gượng gạo từ các ngôn ngữ khác, mình cố gắng để thiết kế một ngôn ngữ sao cho các câu lệnh trông tự nhiên như tiếng Việt nhất có thể, thuận tiện cho người Việt nhất có thể. Điển hình là bạn có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</p>
<p>Ngôn ngữ sẽ có hơi thiên hướng toán học, những bạn học toán có thể sẽ cảm thấy quen thuộc hơn, vì mình định hướng ngôn ngữ được sử dụng như một CAS (Computer Algebra System). Tuy nhiên VanVo vẫn có thể dùng như một ngôn ngữ đa mục đích (General-purpose language) thông thường.</p>
<h2>Điểm qua một số tính năng của VanVo</h2>
<ul>
<li>
<p>Hỗ trợ những câu lệnh rẽ nhánh, cấu trúc lặp, cấu trúc dữ liệu và phép toán cơ bản.</p>
</li>
<li>
<p>Hỗ trợ phân số và số phức.</p>
</li>
<li>
<p>Có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</p>
</li>
<li>
<p>Không cần <code>;</code> ở cuối mỗi câu lệnh, và các khối lệnh sẽ được xác định bởi mức thụt dòng (indent level) như Python.</p>
</li>
<li>
<p>Phép nhân giữa hằng số, biến và mở ngoặc có thể lược bỏ, ví dụ <code>2x(x-1)</code> sẽ tương đương với <code>2*x*(x-1)</code>.</p>
</li>
<li>
<p>List comprehension như <code>{ n*m | n thuộc [1..10], m thuộc [1..10], n != m }</code></p>
</li>
<li>
<p>Lazy evaluation.</p>
</li>
<li>
<p>Các thao tác và phép toán trên tập hợp như hội, giao, hiệu, tích Descartes.</p>
</li>
<li>
<p>Gạch chân chính xác vị trí có lỗi khi chạy chương trình.</p>
</li>
</ul>
<h2>Cài đặt</h2>
<p>Nếu bạn đã tải <a href="https://go.dev/">Go </a>thì cách đơn giản nhất để cài đặt là clone và build trực tiếp từ source như sau</p>
<pre><code class="language-bash">git clone https://github.com/balldk/vanvo
cd vanvo
go install .
</code></pre>
<p>Ngoài ra bạn có thể tải file thực thi tại đây <a href="https://github.com/balldk/vanvo/releases/tag/v0.1.0">Releases v0.1.0</a>.</p>
<p><strong>Cài đặt language support:</strong> Để ngôn ngữ có syntax highlight và snippets trên VSCode thì bạn hãy qua đây cài thêm extension nhé: <a href="https://github.com/balldk/vscode-vanvo">github.com/balldk/vscode-vanvo</a>.</p>
<p>Để chạy chương trình thì ta dùng lệnh</p>
<pre><code class="language-vanvo">vanvo program.vv
</code></pre>
<p>Trong đó <code>program.vv</code> là file chứa nội dung code. Nói chung file extension của VanVo là <code>.vv</code>.</p>
<h2>Một số ví dụ minh họa</h2>
<p><strong>Ví dụ 1:</strong> Xét tính chia hết của n cho 2 và 3, với n là các số nguyên trong khoảng <span class="math inline">\([1,100]\)</span></p>
<pre><code class="language-vanvo">cho A = [1..100]

với mỗi n thuộc A:
	nếu n % 2 == 0:
		xuất n, "chia hết cho 2"
	còn nếu n % 3 == 0:
		xuất n, "chia hết cho 3"
	còn không:
		xuất n, "không chia hết cho cả 2 và 3"
</code></pre>
<p><strong>Ví dụ 2:</strong> Tính giá trị của hàm hợp, với <span class="math inline">\((f.g)(x) = f(g(x))\)</span></p>
<pre><code class="language-vanvo">cho f(x) = 2x(x^2 - 2x)(3x - 5)
cho g(x) = 5x

cho a = 5
xuất f.g(a)
</code></pre>
<p><code>2x(x^2 - 2x)(3x - 5)</code> là cách viết ngắn gọn hơn của <code>2*x*(x^2 - 2*x)*(3*x - 5)</code>.</p>
<p><strong>Ví dụ 3:</strong> Sử dụng list comprehension để định nghĩa mảng vô hạn các phần tử, với <code>fib[i]</code> là phần tử thứ <code>i</code> trong dãy fibonacci</p>
<pre><code class="language-vanvo">cho fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuộc [3..] }

với mỗi n thuộc fib:
    xuất n
</code></pre>
<p>List comprehension có tính “lazy”,  tức là chỉ khi ta cần dùng phần tử nào trong mảng thì phần tử đó mới được tính ra, do đó ta có thể dễ dàng định nghĩa ra mảng vô hạn phần tử trong VanVo.</p>
<h2>Cú pháp</h2>
<p><strong>Lưu ý</strong>: vì mình có sử dụng ligature font cho code trên web nên các kí hiệu như =>, >=, &lt;=, ==, != sẽ trở thành <code>=></code>, <code>>=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>.</p>
<h3>Quy định đặt tên và từ khóa</h3>
<p>Tên định danh là tên được bạn đặt cho biến và hàm trong chương trình, VanVo bao gồm các quy tắc đặt tên định danh như sau:</p>
<ul>
<li>Có thể chứa các kí tự <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>_</code> và toàn bộ bảng chữ cái cũng như dấu trong tiếng Việt.</li>
<li>Không được bắt đầu bằng một chữ số.</li>
<li>Khác với hầu hết các ngôn ngữ khác, VanVo cho phép bạn đặt tên định danh với khoảng trắng, nhưng có một lưu ý là khoảng trắng giữa các từ không quan trọng, ví dụ <code>nguyên tố</code> và <code>nguyên   tố </code> là hai tên định danh giống nhau.</li>
<li>Phân biệt hoa thường (case sensitive).</li>
<li>Không được đặt tên định danh trùng với từ khóa.</li>
</ul>
<p>Danh sách các từ khóa trong VanVo:</p>
<p><code>cho</code>, <code>thuộc</code>, <code>và</code>, <code>hay</code>, <code>với</code>, <code>với mỗi</code>, <code>nếu</code>, <code>còn nếu</code>, <code>còn không</code>, <code>đúng</code>, <code>sai</code>, <code>nhập</code>, <code>xuất</code></p>
<p><strong>Note:</strong> Bạn có thể viết các từ khóa không dấu, ví dụ <code>neu</code>, <code>voi</code> là các từ khóa hợp lệ. Tuy nhiên bạn chỉ có thể viết đầy đủ dấu hoặc là viết không dấu hoàn toàn, ví dụ <code>đung</code> không phải là một từ khóa hợp lệ vì thiếu dấu sắc.</p>
<h3>Khai báo biến</h3>
<p>Biến được định nghĩa thông qua từ khóa <code>cho</code>, với cấu trúc như sau</p>
<pre><code class="language-bnf">cho &lt;tên biến> = &lt;biểu thức>
</code></pre>
<p>Ví dụ</p>
<pre><code class="language-vanvo">cho x = 10.2
cho ngày sinh = 15
</code></pre>
<p>Một số hằng số được định nghĩa sẵn</p>
<pre><code class="language-vanvo">xuất Pi // 3.14159...
xuất E  // 2.71828...
</code></pre>
<h3>Khai báo hàm</h3>
<p>Khai báo hàm tương đối giống với khai báo biến</p>
<pre><code class="language-bnf">cho &lt;tên hàm>(&lt;danh sách các tham số>) = &lt;biểu thức>
</code></pre>
<p>Ví dụ</p>
<pre><code class="language-vanvo">cho f(x,y,z) = 2x(x^2 - 2x + 1) - y^z
xuất f(100, 5, 3)
</code></pre>
<p>Ở ví dụ trên, hàm chỉ được định nghĩa ngắn gọn trong một hàng, để viết một số hàm phức tạp, cần thực hiện nhiều câu lệnh hơn, ta có thể dùng “Biểu thức nhóm”</p>
<pre><code class="language-vanvo">cho f(x) = (cho a = 5; cho b = 6; a+b+x)
xuất f(2) // 13
</code></pre>
<p>Biểu thức cuối cùng trong biểu thức nhóm sẽ là giá trị trả về cho toàn bộ biểu thức, ở ví dụ trên <code>a+b+x = 5+6+2 = 13</code> là giá trị của <code>f(2)</code></p>
<p>Trên thực tế ta sẽ xuống dòng tách các câu lệnh trong biểu thức nhóm</p>
<pre><code class="language-vanvo">// Trả về đúng, nếu n là số chẵn, sai nếu n là số lẻ
cho là chẵn(n) = (
	cho two = 2
	nếu n % two == 0:
		=> đúng
	sai
)
</code></pre>
<p>Dấu suy ra <code>=></code> có ý nghĩa tương đương với câu lệnh <code>return</code> ở những ngôn ngữ khác, khi gặp <code>=></code> thì biểu thức nhóm sẽ kết thúc và trả về giá trị cho biểu thức</p>
<p>Một số hàm được định nghĩa sẵn</p>
<pre><code class="language-vanvo">xuất cos(Pi)  // -1
xuất sin(Pi)  // 0
xuất tan(Pi)  // 0
xuất E^ln(2)  // 2
</code></pre>
<h3>Các kiểu dữ liệu cơ bản</h3>
<pre><code class="language-vanvo">// Số nguyên
15
// số thực
3.14
// Phân số
3/14
// Số phức
3/2 - 2I
// Logic
đúng
sai
</code></pre>
<h3>Phép toán</h3>
<h4>Số học</h4>
<pre><code class="language-vanvo">cho a = 4
cho b = 5/2

xuất a + b  // 13/2
xuất a - b  // 3/2
xuất a * b  // 10
xuất a / b  // 8/5
xuất a ^ b  // 32
xuất a % 7  // 4
</code></pre>
<h4>Logic</h4>
<pre><code class="language-vanvo">xuất 1 == 2  // sai
xuất 1 != 2  // đúng
xuất 1 &lt; 1   // sai
xuất 1 &lt;= 1  // đúng
xuất 1 > 1   // sai
xuất 1 >= 1  // đúng

xuất đúng và sai  // sai
xuất đúng hay sai // đúng
</code></pre>
<h4>Toán tử ba ngôi</h4>
<p>Cấu trúc của toán tử ba ngôi</p>
<pre><code class="language-bnf">&lt;biểu thức 1> nếu &lt;điều kiện> còn không &lt;biểu thức 2>
</code></pre>
<p>Nếu <code>&lt;điều kiện></code> thỏa thì toán tử ba ngồi sẽ trả về giá trị của <code>&lt;biểu thức 1></code>, còn không thì trả về giá trị của <code>&lt;biểu thức 2</code>>. Ví dụ</p>
<pre><code class="language-vanvo">cho gtln(a, b) = a nếu a > b còn không b
xuất gtln(2, 3)  // 3	
</code></pre>
<h3>Câu lệnh điều kiện</h3>
<p>Câu lệnh điều kiện có cấu trúc như sau</p>
<pre><code class="language-bnf">nếu &lt;điều kiện 1>:
	...
còn nếu &lt;điều kiện 2>:
	...
còn không:
	...
</code></pre>
<p><code>...</code> ở đây là khối lệnh, một khối lệnh được xác định bởi mức thụt dòng (indent level) của đoạn code. Không như Python, ở trong VanVo thì indent size được cố định là 4, tab cũng được chương trình mặc định hiểu là 4 spaces.</p>
<p>Ví dụ: xác định <code>n</code> là âm, dương hay 0</p>
<pre><code class="language-vanvo">cho n = 100

nếu n &lt; 0:
	xuất n, "là số âm"
còn nếu n > 0:
	xuất n, "là số dương"
còn không:
	xuất n, "là 0"
</code></pre>
<h3>Cấu trúc lặp</h3>
<p>Trong VanVo có hai cấu trúc lặp là <code>với</code> và <code>với mỗi</code>, <code>với</code> có ý nghĩa tương đương với <code>while</code> ở những ngôn ngữ khác, còn <code>với mỗi</code> sẽ ý nghĩa tương tự như vòng lặp <code>for</code> nhưng không giống hoàn toàn mà sẽ có những đặc trưng riêng.</p>
<h4>Với</h4>
<p><code>với</code> có cấu trúc như sau</p>
<pre><code class="language-bnf">với &lt;danh sách điều kiện>:
	...
</code></pre>
<p>Vòng lặp sẽ được thực hiện cho đến khi một trong các điều kiện của <code>&lt;danh sách điều kiện></code> không thỏa thì vòng lặp dừng lại.</p>
<p>Ví dụ: xuất ra các số trong khoảng <span class="math inline">\([0,100)\)</span></p>
<pre><code class="language-vanvo">cho i = 0
với 0 &lt;= i, i &lt; 100:
	xuất i
	i = i + 1
</code></pre>
<p>Điều kiện <code>0 &lt;= i, i &lt; 100</code> tương đương với <code>0 &lt;= i và i &lt; 100</code>. Ngoài ra bạn có thể sử dụng chaining comparison operator <code>0 &lt;= i &lt; 100</code> để ngắn gọn hơn.</p>
<h4>Với mỗi</h4>
<p><code>với mỗi</code> có cấu trúc như sau</p>
<pre><code class="language-bnf">với mỗi &lt;biến> thuộc &lt;tập đếm được>, &lt;ràng buộc>,...:
	...
</code></pre>
<p>Hãy thử nhìn vào ví dụ trước nhé, chương trình sau sẽ xuất ra các số chẵn trong khoảng <span class="math inline">\([1,100]\)</span></p>
<pre><code class="language-vanvo">với mỗi n thuộc [1..100], x % 2 == 0:
	xuất n

// Output:
2
4
6
...
100
</code></pre>
<p>Ở chương trình trên, <code>n</code> lặp qua từng phần tử trong <code>[1..100]</code>, với <code>[1..100]</code> là tập các số nguyên trong khoảng từ 1 đến 100. Nếu <code>n</code> thỏa mọi ràng buộc được cho thì khối lệnh bên trong sẽ được thực hiện (trong trường hợp này thì ràng buộc là <code>n % 2 == 0</code>). Dĩ nhiên không phải tập hợp nào cũng có thể lặp qua được, phần tiếp theo sẽ giải thích vấn đề này chi tiết hơn.</p>
<p>Bạn có thể lặp qua nhiều tập và có nhiều ràng buộc cùng một lúc, lấy ví dụ</p>
<pre><code class="language-vanvo">với mỗi n thuộc [1..5], m thuộc [3..5], n % 2 == 0, m % 2 == 1:
	xuất n, m

// Output:
2 3
2 5
4 3
4 5
</code></pre>
<h3>Tập hợp</h3>
<p>Ban đầu khi mình phát thảo ý tưởng cho ngôn ngữ này thì mình lấy tập hợp, các phép toán và mệnh đề trên tập hợp làm tư tưởng chính. Nhưng càng về sau thì mình nhận ra là để xây dựng khái niệm tập hợp chuẩn thì tương đối không hiệu quả, và hầu hết các trường hợp thì mảng vẫn hữu dụng hơn, cho nên khái niệm mảng và tập hợp trong VanVo mình sẽ dùng trùng lặp nhau, bạn đọc nên hiểu hai khái niệm này trong VanVo là một, nhưng chúng không tương đương với khái niệm tập hợp thông thường.</p>
<p>Trong VanVo có những tập hợp được gọi là <strong>Tập đếm được</strong>, bạn có thể truy cập chỉ số (indexing) và lặp qua tập đếm được, những tập còn lại được gọi là <strong>Tập không đếm được</strong>. Sau đây là các loại tập hợp hiện có trong VanVo.</p>
<h4>Khoảng Thực (Real interval)</h4>
<p>Khoảng thực <span class="math inline">\([a,b]\)</span> là tập các số thực <span class="math inline">\(x\)</span> sao cho <span class="math inline">\(a\leq x \leq b\)</span>, bạn có thể dùng toán tử <code>thuộc</code> để xét xem một giá trị <span class="math inline">\(x\)</span> có thuộc vào một tập hay không, lấy ví dụ</p>
<pre><code class="language-vanvo">cho A = [0,5]

xuất 2 thuộc A    // đúng
xuất 5 thuộc A    // đúng
xuất -1 thuộc A   // sai
xuất I thuộc A    // sai
</code></pre>
<p>Khoảng thực là Tập không đếm được.</p>
<h4>Khoảng đều</h4>
<p>Khoảng đều <span class="math inline">\([a..b]\)</span> là tập các số <span class="math inline">\(n\)</span> sao cho <span class="math inline">\(a \leq n \leq b\)</span>, và các phần tử liên tiếp cách nhau đúng một đơn vị, lấy ví dụ</p>
<pre><code class="language-vanvo">cho a = 1.2
cho b = 5
cho A = [a..b]

với mỗi x thuộc A:
	xuất x

xuất b thuộc A

// Output:
1.2
2.2
3.2
4.2
sai
</code></pre>
<p>Từ ví dụ trên ta có thể nhận thấy Khoảng đều là một Tập đếm được.</p>
<p>Bạn có thể đặt bước nhảy (step) cho một Khoảng với cú pháp <code>[a..b, step]</code>, ví dụ</p>
<pre><code class="language-vanvo">với mỗi n thuộc [0..4, 2]:
	xuất n

// Output:
0
2
4
</code></pre>
<h4>Danh sách (List)</h4>
<p>Danh sách sẽ tương đối giống mảng thông thường ở những ngôn ngữ khác, với cú pháp <code>{a, b, c, ...}</code>, ví dụ</p>
<pre><code class="language-vanvo">cho A = {1, 2, "hello", đúng}

với mỗi phần tử thuộc A:
	xuất phần tử

// Output:
1
2
"hello"
đúng
</code></pre>
<h4>List comprehension</h4>
<p>Mình cũng không rõ phải dịch khái niệm này ra như thế nào, nhưng riêng trong VanVo thì list comprehension sẽ có cấu trúc giống y như cách chúng ta biểu diễn tập hợp trong toán</p>
<pre><code class="language-bnf">{ &lt;biểu thức> | &lt;biến> thuộc &lt;tập đếm được>, &lt;ràng buộc> }
</code></pre>
<p>Có thể thấy cấu trúc của list comprehension và vòng lặp “với mỗi” có sự tương đồng nhất định, vì chúng thật sự có cơ chế gần giống nhau, ta có thể hiểu <code>&lt;biểu thức></code> ở đây là phần thân của vòng lặp, và giá trị của <code>&lt;biểu thức></code> sẽ là từng phần tử trong tập trên.</p>
<p>Ví dụ: Xây dựng tập các số nguyên dương chẵn</p>
<pre><code class="language-vanvo">cho A = { n | n thuộc [1..], n % 2 == 0 }
</code></pre>
<p>Hoặc đơn giản hơn là</p>
<pre><code class="language-vanvo">cho A = { 2n | n thuộc [1..] }
</code></pre>
<p>Bạn có thể nghi ngờ rằng khi chạy câu lệnh trên thì chương trình bị vướng vào vòng lặp vô hạn và không thể chạy tiếp những câu lệnh khác, nhưng thực tế thì chương trình vẫn tiếp tục chạy những câu lệnh tiếp theo, bạn có thể thao tác trên <code>A</code>, hay lấy ra bất kì phần tử nào trong tập <code>A</code> đó mà bạn muốn. Lý do ta có thể làm được việc này là vì VanVo có hỗ trợ lazy evaluation cho list comprehension, chỉ khi bạn cần phần tử nào thì chương trình mới tính ra phần tử đó (và các phần tử trước) rồi lưu lại. Vì vậy ta có thể dễ dàng định nghĩa ra mảng vô hạn các phần tử trong VanVo.</p>
<h4>Các thao tác và phép toán trên tập hợp</h4>
<p><strong>Lực lượng (#)</strong>: Hiện tại chỉ có thể lấy lực lượng (số phần tử) trên Tập đếm được</p>
<pre><code>cho A = [1..100, 2]
cho B = {3, 5, 7}

#A      // 50
#B      // 3
#(A-B)  // 50
</code></pre>
<p><strong>Chỉ số:</strong> Tương tự, chỉ có Tập đếm được mới có chỉ số</p>
<pre><code>cho A = [1..100, 2]
cho fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuoc [3..] }

A[1]     // 3
fib[50]  // 12586269025
</code></pre>
<p><strong>Phép hội (+)</strong>: Đối với trường hợp lấy hội 2 Tập đếm được thì ta hiểu đây là phép hợp nối mảng sẽ chính xác hơn</p>
<pre><code class="language-vanvo">cho A = {1, 2} + [6..10]  // {1, 2, 6, 7, 8, 9, 10}
cho B = {1, 2} + [6, 10]  // B là Tập không đếm được

8.2 thuộc B  // đúng
</code></pre>
<p><strong>Phép hiệu (-)</strong></p>
<pre><code class="language-vanvo">cho A = [1..9] - [4, 6]  // {1, 2, 3, 7, 8, 9}
cho B = [1, 9] - [4, 6]  // B là Tập không đếm được

7 thuộc B  // đúng
</code></pre>
<p><strong>Tích Descartes (*)</strong></p>
<pre><code class="language-vanvo">cho A = [1..3]
cho B = [1..3]

A*B
// { {1, 1}, {1, 2}, {1, 3}, 
//   {2, 1}, {2, 2}, {2, 3},
//   {3, 1}, {3, 2}, {3, 3} }
</code></pre>
<h2>Túm cái váy</h2>
<p>Hiện tại ngôn ngữ vẫn còn sơ khai và sẽ còn nhiều thay đổi trong thời gian tới, nhìn chung thì dự án này cũng chỉ là sở thích cá nhân thôi, mình không có ý định tạo ra với mục đích thay thế bất kì ngôn ngữ nào trên thị trường cả nên các bạn có ý kiến đóng góp hay ý tưởng gì thì cồm men bên dưới nhẹ nhàng hoặc có thể tạo issue trên github nhé.</p>
</div> <div class="post-hashtag-container"><div class="tag-title"><p>Tags:</p></div> <div><a href="/?tags=project" class="hashtag" data-v-578e9d56>
        #project
    </a></div></div></div> <div class="comment-section"><div class="comment-divider"></div> <div class="comment-input-container"><!----> <div class="comment-login"><p>Tham gia bình luận với</p> <button class="comment-login-site"><i class="fab fa-github"></i></button> <p>hoặc</p> <button class="comment-login-site"><i class="fab fa-google"></i></button></div></div> <div class="comment-list"></div></div></div> <div id="footer"><p id="footer-text">
        Created by
            <a href="https://www.facebook.com/100007015541619" target="_blank"><span></span></a>
        with
        <span id="footer-emoji-heart" class="fas fa-heart"></span>
        and some 
        <span id="footer-emoji-tear" class="fas fa-tint"></span></p></div></article></div></div></div><script defer src="/_nuxt/static/1686154158/posts/vanvo/state.js"></script><script src="/_nuxt/3b3cbff.js" defer></script><script src="/_nuxt/a552c39.js" defer></script><script src="/_nuxt/2724976.js" defer></script><script src="/_nuxt/2d0a0ae.js" defer></script><script src="/_nuxt/8538b13.js" defer></script><script src="/_nuxt/982a32e.js" defer></script><script src="/_nuxt/edb7dc6.js" defer></script>
  </body>
</html>
