<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>K&#39;s corner blog</title>
    <link>https://balldk.github.io</link>
    <description>K&#39;s corner blog, mostly about maths and programming</description>
    <managingEditor> (ND Dang Khoa)</managingEditor>
    <pubDate>Fri, 11 Aug 2023 17:15:08 +0700</pubDate>
    <image>
      <url>https://balldk.github.io/logo.svg</url>
      <title>logo</title>
      <link></link>
    </image>
    <item>
      <title>(P1) Ghi chú về tôpô đại số</title>
      <link>https://balldk.github.io/posts/algebraic-topo-note-1</link>
      <description>&lt;p&gt;Đây là một số ghi chú của mình trong quá trình học topo đại số, tài liệu tham khảo chủ yếu là cuốn &lt;em&gt;An introduction to algebraic topology&lt;/em&gt; của Joseph Rotman. Những lời dẫn và cách hiểu của mình&amp;hellip;&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<p>Đây là một số ghi chú của mình trong quá trình học topo đại số, tài liệu tham khảo chủ yếu là cuốn <em>An introduction to algebraic topology</em> của Joseph Rotman. Những lời dẫn và cách hiểu của mình về các khái niệm trong bài viết được thể hiện ở dưới góc nhìn là một người mới và đang học về topo đại số nên có thể không hoàn toàn đúng. Vì vậy nếu có bất kì khuất mắt hay sai sót nào thì mọi người cứ <del>chửi</del> góp ý cho mình nhé.</p>
<p>Đại khái topo đại số là bộ môn sử dụng những công cụ đại số, cấu trúc đại số để nghiên cứu topo. Topo đại số đưa ra những <em>tính chất bất biến</em> dựa trên các khái niệm đại số, điển hình là <em>nhóm cơ bản</em> của một không gian topo. Nhóm cơ bản có thể coi là một cách để ta phát hiện ra các lỗ (genus) của một đối tượng topo. Lấy ví dụ, ta xét hình xuyến (torus) và chọn một điểm <span class="math inline">\(x_0\)</span> cố định trên đó, sau đó ta xét tất cả các đường đi kín có điểm xuất phát và kết thúc tại <span class="math inline">\(x_0\)</span> (như hình minh họa)</p>
<p><img src="https://i.imgur.com/BFLN2Q0.png" alt="torus"></p>
<p>Để ý về mặt trực quan, đường đi <span class="math inline">\(a_1\)</span> có thể co giãn biến đổi liên tục để trở thành <span class="math inline">\(a_2\)</span>, thậm chí ta có thể co <span class="math inline">\(a_1\)</span> lại hẳn thành điểm <span class="math inline">\(x_0\)</span>. Tương tự <span class="math inline">\(c_1\)</span> có thể biến đổi liên tục thành <span class="math inline">\(c_2\)</span>, nhưng <span class="math inline">\(c_1\)</span> không thể biến đổi liên tục để thành <span class="math inline">\(a_1\)</span> được vì ta không thể co <span class="math inline">\(c_1\)</span> lại thành một điểm. Vì thế đường đi <span class="math inline">\(c_1\)</span> và <span class="math inline">\(c_2\)</span> trên phương diện nào đó giúp ta phát hiện được &ldquo;lỗ&rdquo; của hình xuyến. Quan hệ <span class="math inline">\(f\)</span> có thể biến đổi liên tục thành <span class="math inline">\(g\)</span> được gọi là quan hệ đồng luân. Hơn nữa ta có thể định nghĩa phép toán trên tập các đường đi đó theo nghĩa với <span class="math inline">\(a,b\)</span> là hai đường đi thì <span class="math inline">\(a*b\)</span> là đường đi qua <span class="math inline">\(a\)</span>, sau đó qua <span class="math inline">\(b\)</span>. Lúc này ta xét tập các lớp tương đương của các đường đi đó theo quan hệ đồng luân, kèm theo phép toán được định nghĩa như trên, sẽ trở thành một nhóm. Ta gọi nhóm này là <em>nhóm cơ bản</em> của hình xuyến với điểm mút là <span class="math inline">\(x_0\)</span>. Để tính được nhóm cơ bản của hình xuyến không phải điều hiểu nhiên. Ta thử xét một ví dụ khác</p>
<p><img src="https://i.imgur.com/eZY9sfE.png" alt="sphere_draw"></p>
<p>Đây là mặt cầu với điểm cố định <span class="math inline">\(x_0\)</span>. Khi đó mọi đường đi lấy <span class="math inline">\(x_0\)</span> là điểm mút đều có thể co lại thành một điểm, tức là chúng đồng luân với nhau. Vậy nên nhóm cơ bản của mặt cầu chỉ có một phần tử, và đó chính xác là nhóm tầm thường. Bây giờ chúng ta sẽ đi vào chi tiết.</p>
<p><em>Note:</em> Tính chất bất biến của không gian topo là tính chất không thay đổi giữa các không gian topo đồng phôi với nhau.</p>
<p><strong>Định nghĩa:</strong> Cho <span class="math inline">\(f,g: X \rightarrow Y\)</span> là hai ánh xạ liên tục. <span class="math inline">\(f\)</span> đươc gọi là <em>đồng luân</em> (homotopic) với <span class="math inline">\(g\)</span> nếu tồn tại <span class="math inline">\(F: X \times [0,1] \rightarrow Y\)</span> liên tục thỏa <span class="math inline">\(\forall x \in X\)</span>,</p>
<p><span class="math display">\[F(x,0) = f(x) \text{ và } F(x,1) = g(x)
\]</span></p>
<p>ta nói <span class="math inline">\(F\)</span> là một đồng luân (homotopy) từ <span class="math inline">\(f\)</span> vào <span class="math inline">\(g\)</span>, kí hiệu <span class="math inline">\(F: f \simeq g\)</span>.</p>
<p>Nếu ta đặt <span class="math inline">\(F_t(x) = F(x,t)\)</span> thì khi đó ta có thể coi <span class="math inline">\(F\)</span> là họ các hàm liên tục <span class="math inline">\(F_t: X \rightarrow Y\)</span> thể hiện sự biến dạng từ <span class="math inline">\(F_0 = f\)</span> sang <span class="math inline">\(F_1 = g\)</span> với tham số thời gian <span class="math inline">\(t\)</span>.</p>
<p>Lưu ý rằng ta coi không gian <span class="math inline">\([0,1]\)</span> ở đây là không gian con của <span class="math inline">\(\R\)</span> với topo Euclid thông thường, và <span class="math inline">\(X \times [0,1]\)</span> là không gian topo tích (product topology). Để tiện hơn thì từ giờ ta kí hiệu <span class="math inline">\(I = [0,1]\)</span>.</p>
<p><strong>Định lí:</strong> Đồng luân là quan hệ tương đương trên tập các ánh xạ liên tục từ <span class="math inline">\(X \rightarrow Y\)</span>.</p>
<p><em>Chứng minh:</em></p>
<ul>
<li>
<p>Phản xạ: Với <span class="math inline">\(f:X \rightarrow Y\)</span> liên tục, ta định nghĩa <span class="math inline">\(F(x,t) = f(x), \forall x \in X, t \in I\)</span>. <span class="math inline">\(F\)</span> liên tục do <span class="math inline">\(f\)</span> liên tục. Vậy <span class="math inline">\(F: f\simeq f\)</span>.</p>
</li>
<li>
<p>Đối xứng: Với <span class="math inline">\(f,g:X \rightarrow Y\)</span> liên tục. Giả sử <span class="math inline">\(F: f \simeq g\)</span>. Ta xét <span class="math inline">\(G(x,t) = F(x,1-t)\)</span> liên tục. Hơn nữa <span class="math inline">\(G(x,0) = F(x,1) = g(x)\)</span> và <span class="math inline">\(G(x,1) = F(x,0) = f(x)\)</span>. Vậy <span class="math inline">\(G: g \simeq f\)</span>.</p>
</li>
<li>
<p>Bắc cầu: Với <span class="math inline">\(f,g,h: X \rightarrow Y\)</span>. Giả sử <span class="math inline">\(F: f \simeq g\)</span> và <span class="math inline">\(G: g \simeq h\)</span>. Đặt</p>
<p><span class="math display">\[H(x,t) = \begin{cases}
F(x,2t) & 0 \leq t \leq \frac{1}{2}\\
G(x,2t-1) & \frac{1}{2} \leq t \leq 1
\end{cases}
\]</span></p>
<p><span class="math inline">\(H\)</span> định nghĩa tốt do <span class="math inline">\(H(x,\frac{1}{2}) = F(x,1) = G(x,0) = g(x)\)</span>. Vì <span class="math inline">\(F\)</span> và <span class="math inline">\(G\)</span> liên tục nên theo bổ đề dán thì <span class="math inline">\(H\)</span> liên tục. Ngoài ra <span class="math inline">\(H(x,0) = F(x,0) = f(x)\)</span> và <span class="math inline">\(H(x,1) = G(x,1) = h(x)\)</span>. Vậy <span class="math inline">\(H: f \simeq g\)</span>.</p>
</li>
</ul>
<p><strong>Định nghĩa:</strong> Cho <span class="math inline">\(f: X \rightarrow Y\)</span> liên tục, ta định nghĩa <em>lớp đồng luân</em> của <span class="math inline">\(f\)</span> là tập các ánh xạ liên tục <span class="math inline">\(g: X \rightarrow Y\)</span> đồng luân với <span class="math inline">\(f\)</span>, nghĩa là</p>
<p><span class="math display">\[[f] = \{g: X \rightarrow Y \text{ liên tục } | f \simeq g\}
\]</span></p>
<p>Họ các lớp đồng luân như vậy ta kí hiệu là <span class="math inline">\([X,Y]\)</span>.</p>
<p><strong>Định lí:</strong> Cho <span class="math inline">\(f_0,f_1: X \rightarrow Y\)</span> và <span class="math inline">\(g_0,g_1: Y \rightarrow Z\)</span> liên tục. Khi đó nếu <span class="math inline">\(f_0 \simeq f_1\)</span> và <span class="math inline">\(g_0 \simeq g_1\)</span> thì <span class="math inline">\(g_0 \circ f_0 \simeq g_1 \circ f_1\)</span>, nói cách khác <span class="math inline">\([g_0 \circ f_0] = [g_1 \circ f_1]\)</span>.</p>
<p><em>Chứng minh:</em> Giả sử <span class="math inline">\(F: f_0 \simeq f_1\)</span> và <span class="math inline">\(G: g_0 \simeq g_1\)</span>. Trước tiên ta sẽ đi chứng minh</p>
<p><span class="math display">\[g_0 \circ f_0 \simeq g_1 \circ f_0 \tag{*}
\]</span></p>
<p>Xét <span class="math inline">\(H: X \times I \rightarrow Z\)</span> được định nghĩa bởi <span class="math inline">\(H(x,t) = G(f_0(x), t)\)</span>. Dễ thấy <span class="math inline">\(H\)</span> liên tục. Hơn nữa <span class="math inline">\(H(x,0) = G(f_0(x), 0) = g_0(f_0(x))\)</span> và  <span class="math inline">\(H(x,1) = G(f_0(x), 1) = g_1(f_0(x))\)</span>. Suy ra <span class="math inline">\(H: g_0 \circ f_0 \simeq g_1 \circ f_0\)</span>.</p>
<p>Tiếp theo ta đi chứng minh</p>
<p><span class="math display">\[g_0 \circ f_0 \simeq g_0 \circ f_1 \tag{**}
\]</span></p>
<p>Thật vậy, xét <span class="math inline">\(K = g_1 \circ F: X \times I \rightarrow Z\)</span> liên tục thỏa <span class="math inline">\(K(x,0) = g_1(F(x,0)) = g_1 \circ f_0 (x)\)</span> và <span class="math inline">\(K(x,1) = g_1(F(x,1)) = g_1 \circ f_1 (x)\)</span>. Vậy nên <span class="math inline">\(K: g_0 \circ f_0 \simeq g_0 \circ f_1\)</span>.</p>
<p>Từ <span class="math inline">\((*)\)</span> và <span class="math inline">\((**)\)</span> suy ra <span class="math inline">\(g_0 \circ f_0 \simeq g_1 \circ f_1\)</span>  (điều phải chứng minh).</p>
<p><strong>Định nghĩa:</strong> Ánh xạ liên tục <span class="math inline">\(f: X \rightarrow Y\)</span> được gọi là một <em>tương đương đồng luân</em> (homotopy equivalence) nếu tồn tại <span class="math inline">\(g: Y \rightarrow X\)</span> thỏa</p>
<p><span class="math display">\[g \circ f \simeq 1_X \text{ và } f \circ g \simeq 1_Y
\]</span></p>
<p>Hơn nữa, ta nói hai không gian topo <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> có <em>cùng loại đồng luân</em> nếu tồn tại một tương đương đồng luân <span class="math inline">\(f: X \rightarrow Y\)</span>.</p>
<p><strong>Định nghĩa:</strong> Ta nói ánh xạ liên tục <span class="math inline">\(f: X \rightarrow Y\)</span> là <em>đồng luân không</em> (nullhomotopic) nếu <span class="math inline">\(f\)</span> đồng luân với ánh xạ hằng, tức là tồn tại <span class="math inline">\(k: X \rightarrow Y\)</span> thỏa  <span class="math inline">\(k(x) = y_0 \in Y,\forall x \in X\)</span> sao cho <span class="math inline">\(f \simeq k\)</span>.</p>
<p><strong>Định lí:</strong> Cho <span class="math inline">\(f: S^n \rightarrow Y\)</span> liên tục. Khi đó những điều sau tương đương</p>
<p><span class="math inline">\((i)\ f\)</span> đồng luân không.</p>
<p><span class="math inline">\((ii)\ f\)</span> có thể mở rộng thành ánh xạ liên tục từ <span class="math inline">\(D^{n+1} \rightarrow Y\)</span>.</p>
<p><span class="math inline">\((iii)\)</span> Nếu <span class="math inline">\(x_0 \in S^n\)</span> và <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng mang giá trị tại <span class="math inline">\(f(x_0)\)</span> thì tồn tại một đồng luân <span class="math inline">\(F: f \simeq k\)</span> thỏa <span class="math inline">\(F(x_0, t) = f(x_0)\)</span> với mọi <span class="math inline">\(x \in I\)</span>.</p>
<p><em>Chứng minh:</em> <span class="math inline">\((i) \Rightarrow (ii)\)</span>: Giả sử <span class="math inline">\(F: f \simeq c\)</span> với <span class="math inline">\(c(x) = y_0, \forall x \in S^n\)</span>. Xét <span class="math inline">\(g: D^{n+1} \rightarrow Y\)</span> xác định bởi</p>
<p><span class="math display">\[g(x) = \begin{cases}
	F\left(\frac{x}{\|x\|}, 1 - \|x\|\right) & \|x\| \neq 0\\
	y_0 & \|x\| = 0
\end{cases}
\]</span></p>
<p><span class="math inline">\(g\)</span> định nghĩa tốt do với <span class="math inline">\(x \in D^{n+1}\)</span> thì <span class="math inline">\(\|x\| \in I\)</span>, dẫn tới <span class="math inline">\(\frac{x}{\|x\|} \in S^1\)</span> và <span class="math inline">\(1-\|x\| \in I\)</span>.  Hơn nữa <span class="math inline">\(\forall x \in S^1\)</span>, <span class="math inline">\(g(x) = F(x,0) = f(x)\)</span>. Vậy <span class="math inline">\(f = g_{|S^n}\)</span></p>
<p><span class="math inline">\((ii) \Rightarrow (iii)\)</span>: Giả sử <span class="math inline">\(g: D^{n+1} \rightarrow Y\)</span> là mở rộng của <span class="math inline">\(f\)</span>. Ta xét <span class="math inline">\(F: S^n \rightarrow Y\)</span> thỏa <span class="math inline">\(F(x,t) = g((1-t)x + tx_0)\)</span>. Ở đây <span class="math inline">\((1-t)x + tx_0\)</span> là đoạn thẳng nối <span class="math inline">\(x\)</span> và <span class="math inline">\(x_0\)</span> nên thuộc <span class="math inline">\(D^{n+1}\)</span> do <span class="math inline">\(D^{n+1}\)</span> lồi. Hơn nữa <span class="math inline">\(F(x,0) = g(x) = f(x)\)</span> và <span class="math inline">\(F(x,1) = g(x_0) = f(x_0),\ \forall x \in S^n\)</span>. Do đó <span class="math inline">\(F: f \simeq k\)</span> với <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng mang giá trị tại <span class="math inline">\(f(x_0)\)</span>. Cuối cùng ta có <span class="math inline">\(F(x_0, t) = f(x_0),\ \forall t \in I\)</span>.</p>
<p><span class="math inline">\((iii) \Rightarrow (i)\)</span>: Chọn <span class="math inline">\(x_0\)</span> là điểm bất kì trong <span class="math inline">\(S^n\)</span> và xét <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng tại <span class="math inline">\(f(x_0)\)</span>. Khi đó theo giả thiết thì tồn tại <span class="math inline">\(F: f \simeq k\)</span>. Vậy <span class="math inline">\(f\)</span> đồng luân không.</p>
<p><strong>Định nghĩa:</strong> Không gian topo <span class="math inline">\(X\)</span> được gọi là <em>co lại được</em> (contractible) nếu <span class="math inline">\(1_X\)</span> đồng luân không.</p>
<p><strong>Định lí:</strong> Không gian topo <span class="math inline">\(X\)</span> cùng loại đồng luân với không gian 1 điểm nào đó <span class="math inline">\(\Leftrightarrow X\)</span> co lại được.</p>
<p><em>Chứng minh</em>: Xét <span class="math inline">\(\{a\}\)</span> là không gian 1 điểm bất kì và giả sử <span class="math inline">\(X\)</span> cùng loại đồng luân với <span class="math inline">\(\{a\}\)</span>, tức là tồn tại <span class="math inline">\(f: X \rightarrow \{a\}\)</span> và <span class="math inline">\(g: \{a\} \rightarrow X\)</span> thỏa <span class="math inline">\(g \circ f \simeq 1_X\)</span> và <span class="math inline">\(f \circ g \simeq 1_a\)</span>. Để ý <span class="math inline">\(f\)</span> là hàm hằng tại <span class="math inline">\(a\)</span>, ta có <span class="math inline">\(\forall x \in X\)</span>, <span class="math inline">\(g \circ f(x) = g(a)\)</span>. Do đó <span class="math inline">\(g \circ f\)</span> là hàm hằng, mà <span class="math inline">\(g \circ f \simeq 1_X\)</span> nên <span class="math inline">\(X\)</span> co lại được.</p>
<p>Ngược lại, giả sử <span class="math inline">\(X\)</span> co lại được, tức là <span class="math inline">\(1_X \simeq c\)</span> với <span class="math inline">\(c: X \rightarrow X,\ c(x) = c_0\ \forall x \in X\)</span>. Xét <span class="math inline">\(f: X \rightarrow \{c_0\}\)</span> là hàm hằng và <span class="math inline">\(g: \{c_0\} \rightarrow X,\ g(c_0) = c_0\)</span>.</p>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/algebraic-topo-note-1</guid>
      <pubDate>Fri, 24 Feb 2023 18:28:16 +0700</pubDate>
    </item>
    <item>
      <title>(P2) Ghi chú về tôpô đại số</title>
      <link>https://balldk.github.io/posts/algebraic-topo-note-2</link>
      <description>&lt;p&gt;Đây là một số ghi chú của mình trong quá trình học topo đại số, tài liệu tham khảo chủ yếu là cuốn &lt;em&gt;An introduction to algebraic topology&lt;/em&gt; của Joseph Rotman. Những lời dẫn và cách hiểu của mình&amp;hellip;&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<p>Đây là một số ghi chú của mình trong quá trình học topo đại số, tài liệu tham khảo chủ yếu là cuốn <em>An introduction to algebraic topology</em> của Joseph Rotman. Những lời dẫn và cách hiểu của mình về các khái niệm trong bài viết được thể hiện ở dưới góc nhìn là một người mới và đang học về topo đại số nên có thể không hoàn toàn đúng. Vì vậy nếu có bất kì khuất mắt hay sai sót nào thì mọi người cứ <del>chửi</del> góp ý cho mình nhé.</p>
<p>Đại khái topo đại số là bộ môn sử dụng những công cụ đại số, cấu trúc đại số để nghiên cứu topo. Topo đại số đưa ra những <em>tính chất bất biến</em> dựa trên các khái niệm đại số, điển hình là <em>nhóm cơ bản</em> của một không gian topo. Nhóm cơ bản có thể coi là một cách để ta phát hiện ra các lỗ (genus) của một đối tượng topo. Lấy ví dụ, ta xét hình xuyến (torus) và chọn một điểm <span class="math inline">\(x_0\)</span> cố định trên đó, sau đó ta xét tất cả các đường đi kín có điểm xuất phát và kết thúc tại <span class="math inline">\(x_0\)</span> (như hình minh họa)</p>
<p><img src="https://i.imgur.com/BFLN2Q0.png" alt="torus"></p>
<p>Để ý về mặt trực quan, đường đi <span class="math inline">\(a_1\)</span> có thể co giãn biến đổi liên tục để trở thành <span class="math inline">\(a_2\)</span>, thậm chí ta có thể co <span class="math inline">\(a_1\)</span> lại hẳn thành điểm <span class="math inline">\(x_0\)</span>. Tương tự <span class="math inline">\(c_1\)</span> có thể biến đổi liên tục thành <span class="math inline">\(c_2\)</span>, nhưng <span class="math inline">\(c_1\)</span> không thể biến đổi liên tục để thành <span class="math inline">\(a_1\)</span> được vì ta không thể co <span class="math inline">\(c_1\)</span> lại thành một điểm. Vì thế đường đi <span class="math inline">\(c_1\)</span> và <span class="math inline">\(c_2\)</span> trên phương diện nào đó giúp ta phát hiện được &ldquo;lỗ&rdquo; của hình xuyến. Quan hệ <span class="math inline">\(f\)</span> có thể biến đổi liên tục thành <span class="math inline">\(g\)</span> được gọi là quan hệ đồng luân. Hơn nữa ta có thể định nghĩa phép toán trên tập các đường đi đó theo nghĩa với <span class="math inline">\(a,b\)</span> là hai đường đi thì <span class="math inline">\(a*b\)</span> là đường đi qua <span class="math inline">\(a\)</span>, sau đó qua <span class="math inline">\(b\)</span>. Lúc này ta xét tập các lớp tương đương của các đường đi đó theo quan hệ đồng luân, kèm theo phép toán được định nghĩa như trên, sẽ trở thành một nhóm. Ta gọi nhóm này là <em>nhóm cơ bản</em> của hình xuyến với điểm mút là <span class="math inline">\(x_0\)</span>. Để tính được nhóm cơ bản của hình xuyến không phải điều hiểu nhiên. Ta thử xét một ví dụ khác</p>
<p><img src="https://i.imgur.com/eZY9sfE.png" alt="sphere_draw"></p>
<p>Đây là mặt cầu với điểm cố định <span class="math inline">\(x_0\)</span>. Khi đó mọi đường đi lấy <span class="math inline">\(x_0\)</span> là điểm mút đều có thể co lại thành một điểm, tức là chúng đồng luân với nhau. Vậy nên nhóm cơ bản của mặt cầu chỉ có một phần tử, và đó chính xác là nhóm tầm thường. Bây giờ chúng ta sẽ đi vào chi tiết.</p>
<p><em>Note:</em> Tính chất bất biến của không gian topo là tính chất không thay đổi giữa các không gian topo đồng phôi với nhau.</p>
<p><strong>Định nghĩa:</strong> Cho <span class="math inline">\(f,g: X \rightarrow Y\)</span> là hai ánh xạ liên tục. <span class="math inline">\(f\)</span> đươc gọi là <em>đồng luân</em> (homotopic) với <span class="math inline">\(g\)</span> nếu tồn tại <span class="math inline">\(F: X \times [0,1] \rightarrow Y\)</span> liên tục thỏa <span class="math inline">\(\forall x \in X\)</span>,</p>
<p><span class="math display">\[F(x,0) = f(x) \text{ và } F(x,1) = g(x)
\]</span></p>
<p>ta nói <span class="math inline">\(F\)</span> là một đồng luân (homotopy) từ <span class="math inline">\(f\)</span> vào <span class="math inline">\(g\)</span>, kí hiệu <span class="math inline">\(F: f \simeq g\)</span>.</p>
<p>Nếu ta đặt <span class="math inline">\(F_t(x) = F(x,t)\)</span> thì khi đó ta có thể coi <span class="math inline">\(F\)</span> là họ các hàm liên tục <span class="math inline">\(F_t: X \rightarrow Y\)</span> thể hiện sự biến dạng từ <span class="math inline">\(F_0 = f\)</span> sang <span class="math inline">\(F_1 = g\)</span> với tham số thời gian <span class="math inline">\(t\)</span>.</p>
<p>Lưu ý rằng ta coi không gian <span class="math inline">\([0,1]\)</span> ở đây là không gian con của <span class="math inline">\(\R\)</span> với topo Euclid thông thường, và <span class="math inline">\(X \times [0,1]\)</span> là không gian topo tích (product topology). Để tiện hơn thì từ giờ ta kí hiệu <span class="math inline">\(I = [0,1]\)</span>.</p>
<p><strong>Định lí:</strong> Đồng luân là quan hệ tương đương trên tập các ánh xạ liên tục từ <span class="math inline">\(X \rightarrow Y\)</span>.</p>
<p><em>Chứng minh:</em></p>
<ul>
<li>
<p>Phản xạ: Với <span class="math inline">\(f:X \rightarrow Y\)</span> liên tục, ta định nghĩa <span class="math inline">\(F(x,t) = f(x), \forall x \in X, t \in I\)</span>. <span class="math inline">\(F\)</span> liên tục do <span class="math inline">\(f\)</span> liên tục. Vậy <span class="math inline">\(F: f\simeq f\)</span>.</p>
</li>
<li>
<p>Đối xứng: Với <span class="math inline">\(f,g:X \rightarrow Y\)</span> liên tục. Giả sử <span class="math inline">\(F: f \simeq g\)</span>. Ta xét <span class="math inline">\(G(x,t) = F(x,1-t)\)</span> liên tục. Hơn nữa <span class="math inline">\(G(x,0) = F(x,1) = g(x)\)</span> và <span class="math inline">\(G(x,1) = F(x,0) = f(x)\)</span>. Vậy <span class="math inline">\(G: g \simeq f\)</span>.</p>
</li>
<li>
<p>Bắc cầu: Với <span class="math inline">\(f,g,h: X \rightarrow Y\)</span>. Giả sử <span class="math inline">\(F: f \simeq g\)</span> và <span class="math inline">\(G: g \simeq h\)</span>. Đặt</p>
<p><span class="math display">\[H(x,t) = \begin{cases}
F(x,2t) & 0 \leq t \leq \frac{1}{2}\\
G(x,2t-1) & \frac{1}{2} \leq t \leq 1
\end{cases}
\]</span></p>
<p><span class="math inline">\(H\)</span> định nghĩa tốt do <span class="math inline">\(H(x,\frac{1}{2}) = F(x,1) = G(x,0) = g(x)\)</span>. Vì <span class="math inline">\(F\)</span> và <span class="math inline">\(G\)</span> liên tục nên theo bổ đề dán thì <span class="math inline">\(H\)</span> liên tục. Ngoài ra <span class="math inline">\(H(x,0) = F(x,0) = f(x)\)</span> và <span class="math inline">\(H(x,1) = G(x,1) = h(x)\)</span>. Vậy <span class="math inline">\(H: f \simeq g\)</span>.</p>
</li>
</ul>
<p><strong>Định nghĩa:</strong> Cho <span class="math inline">\(f: X \rightarrow Y\)</span> liên tục, ta định nghĩa <em>lớp đồng luân</em> của <span class="math inline">\(f\)</span> là tập các ánh xạ liên tục <span class="math inline">\(g: X \rightarrow Y\)</span> đồng luân với <span class="math inline">\(f\)</span>, nghĩa là</p>
<p><span class="math display">\[[f] = \{g: X \rightarrow Y \text{ liên tục } | f \simeq g\}
\]</span></p>
<p>Họ các lớp đồng luân như vậy ta kí hiệu là <span class="math inline">\([X,Y]\)</span>.</p>
<p><strong>Định lí:</strong> Cho <span class="math inline">\(f_0,f_1: X \rightarrow Y\)</span> và <span class="math inline">\(g_0,g_1: Y \rightarrow Z\)</span> liên tục. Khi đó nếu <span class="math inline">\(f_0 \simeq f_1\)</span> và <span class="math inline">\(g_0 \simeq g_1\)</span> thì <span class="math inline">\(g_0 \circ f_0 \simeq g_1 \circ f_1\)</span>, nói cách khác <span class="math inline">\([g_0 \circ f_0] = [g_1 \circ f_1]\)</span>.</p>
<p><em>Chứng minh:</em> Giả sử <span class="math inline">\(F: f_0 \simeq f_1\)</span> và <span class="math inline">\(G: g_0 \simeq g_1\)</span>. Trước tiên ta sẽ đi chứng minh</p>
<p><span class="math display">\[g_0 \circ f_0 \simeq g_1 \circ f_0 \tag{*}
\]</span></p>
<p>Xét <span class="math inline">\(H: X \times I \rightarrow Z\)</span> được định nghĩa bởi <span class="math inline">\(H(x,t) = G(f_0(x), t)\)</span>. Dễ thấy <span class="math inline">\(H\)</span> liên tục. Hơn nữa <span class="math inline">\(H(x,0) = G(f_0(x), 0) = g_0(f_0(x))\)</span> và  <span class="math inline">\(H(x,1) = G(f_0(x), 1) = g_1(f_0(x))\)</span>. Suy ra <span class="math inline">\(H: g_0 \circ f_0 \simeq g_1 \circ f_0\)</span>.</p>
<p>Tiếp theo ta đi chứng minh</p>
<p><span class="math display">\[g_0 \circ f_0 \simeq g_0 \circ f_1 \tag{**}
\]</span></p>
<p>Thật vậy, xét <span class="math inline">\(K = g_1 \circ F: X \times I \rightarrow Z\)</span> liên tục thỏa <span class="math inline">\(K(x,0) = g_1(F(x,0)) = g_1 \circ f_0 (x)\)</span> và <span class="math inline">\(K(x,1) = g_1(F(x,1)) = g_1 \circ f_1 (x)\)</span>. Vậy nên <span class="math inline">\(K: g_0 \circ f_0 \simeq g_0 \circ f_1\)</span>.</p>
<p>Từ <span class="math inline">\((*)\)</span> và <span class="math inline">\((**)\)</span> suy ra <span class="math inline">\(g_0 \circ f_0 \simeq g_1 \circ f_1\)</span>  (điều phải chứng minh).</p>
<p><strong>Định nghĩa:</strong> Ánh xạ liên tục <span class="math inline">\(f: X \rightarrow Y\)</span> được gọi là một <em>tương đương đồng luân</em> (homotopy equivalence) nếu tồn tại <span class="math inline">\(g: Y \rightarrow X\)</span> thỏa</p>
<p><span class="math display">\[g \circ f \simeq 1_X \text{ và } f \circ g \simeq 1_Y
\]</span></p>
<p>Hơn nữa, ta nói hai không gian topo <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> có <em>cùng loại đồng luân</em> nếu tồn tại một tương đương đồng luân <span class="math inline">\(f: X \rightarrow Y\)</span>.</p>
<p><strong>Định nghĩa:</strong> Ta nói ánh xạ liên tục <span class="math inline">\(f: X \rightarrow Y\)</span> là <em>đồng luân không</em> (nullhomotopic) nếu <span class="math inline">\(f\)</span> đồng luân với ánh xạ hằng, tức là tồn tại <span class="math inline">\(k: X \rightarrow Y\)</span> thỏa  <span class="math inline">\(k(x) = y_0 \in Y,\forall x \in X\)</span> sao cho <span class="math inline">\(f \simeq k\)</span>.</p>
<p><strong>Định lí:</strong> Cho <span class="math inline">\(f: S^n \rightarrow Y\)</span> liên tục. Khi đó những điều sau tương đương</p>
<p><span class="math inline">\((i)\ f\)</span> đồng luân không.</p>
<p><span class="math inline">\((ii)\ f\)</span> có thể mở rộng thành ánh xạ liên tục từ <span class="math inline">\(D^{n+1} \rightarrow Y\)</span>.</p>
<p><span class="math inline">\((iii)\)</span> Nếu <span class="math inline">\(x_0 \in S^n\)</span> và <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng mang giá trị tại <span class="math inline">\(f(x_0)\)</span> thì tồn tại một đồng luân <span class="math inline">\(F: f \simeq k\)</span> thỏa <span class="math inline">\(F(x_0, t) = f(x_0)\)</span> với mọi <span class="math inline">\(x \in I\)</span>.</p>
<p><em>Chứng minh:</em> <span class="math inline">\((i) \Rightarrow (ii)\)</span>: Giả sử <span class="math inline">\(F: f \simeq c\)</span> với <span class="math inline">\(c(x) = y_0, \forall x \in S^n\)</span>. Xét <span class="math inline">\(g: D^{n+1} \rightarrow Y\)</span> xác định bởi</p>
<p><span class="math display">\[g(x) = \begin{cases}
	F\left(\frac{x}{\|x\|}, 1 - \|x\|\right) & \|x\| \neq 0\\
	y_0 & \|x\| = 0
\end{cases}
\]</span></p>
<p><span class="math inline">\(g\)</span> định nghĩa tốt do với <span class="math inline">\(x \in D^{n+1}\)</span> thì <span class="math inline">\(\|x\| \in I\)</span>, dẫn tới <span class="math inline">\(\frac{x}{\|x\|} \in S^1\)</span> và <span class="math inline">\(1-\|x\| \in I\)</span>.  Hơn nữa <span class="math inline">\(\forall x \in S^1\)</span>, <span class="math inline">\(g(x) = F(x,0) = f(x)\)</span>. Vậy <span class="math inline">\(f = g_{|S^n}\)</span></p>
<p><span class="math inline">\((ii) \Rightarrow (iii)\)</span>: Giả sử <span class="math inline">\(g: D^{n+1} \rightarrow Y\)</span> là mở rộng của <span class="math inline">\(f\)</span>. Ta xét <span class="math inline">\(F: S^n \rightarrow Y\)</span> thỏa <span class="math inline">\(F(x,t) = g((1-t)x + tx_0)\)</span>. Ở đây <span class="math inline">\((1-t)x + tx_0\)</span> là đoạn thẳng nối <span class="math inline">\(x\)</span> và <span class="math inline">\(x_0\)</span> nên thuộc <span class="math inline">\(D^{n+1}\)</span> do <span class="math inline">\(D^{n+1}\)</span> lồi. Hơn nữa <span class="math inline">\(F(x,0) = g(x) = f(x)\)</span> và <span class="math inline">\(F(x,1) = g(x_0) = f(x_0),\ \forall x \in S^n\)</span>. Do đó <span class="math inline">\(F: f \simeq k\)</span> với <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng mang giá trị tại <span class="math inline">\(f(x_0)\)</span>. Cuối cùng ta có <span class="math inline">\(F(x_0, t) = f(x_0),\ \forall t \in I\)</span>.</p>
<p><span class="math inline">\((iii) \Rightarrow (i)\)</span>: Chọn <span class="math inline">\(x_0\)</span> là điểm bất kì trong <span class="math inline">\(S^n\)</span> và xét <span class="math inline">\(k: S^n \rightarrow Y\)</span> là hàm hằng tại <span class="math inline">\(f(x_0)\)</span>. Khi đó theo giả thiết thì tồn tại <span class="math inline">\(F: f \simeq k\)</span>. Vậy <span class="math inline">\(f\)</span> đồng luân không.</p>
<p><strong>Định nghĩa:</strong> Không gian topo <span class="math inline">\(X\)</span> được gọi là <em>co lại được</em> (contractible) nếu <span class="math inline">\(1_X\)</span> đồng luân không.</p>
<p><strong>Định lí:</strong> Không gian topo <span class="math inline">\(X\)</span> cùng loại đồng luân với không gian 1 điểm nào đó <span class="math inline">\(\Leftrightarrow X\)</span> co lại được.</p>
<p><em>Chứng minh</em>: Xét <span class="math inline">\(\{a\}\)</span> là không gian 1 điểm bất kì và giả sử <span class="math inline">\(X\)</span> cùng loại đồng luân với <span class="math inline">\(\{a\}\)</span>, tức là tồn tại <span class="math inline">\(f: X \rightarrow \{a\}\)</span> và <span class="math inline">\(g: \{a\} \rightarrow X\)</span> thỏa <span class="math inline">\(g \circ f \simeq 1_X\)</span> và <span class="math inline">\(f \circ g \simeq 1_a\)</span>. Để ý <span class="math inline">\(f\)</span> là hàm hằng tại <span class="math inline">\(a\)</span>, ta có <span class="math inline">\(\forall x \in X\)</span>, <span class="math inline">\(g \circ f(x) = g(a)\)</span>. Do đó <span class="math inline">\(g \circ f\)</span> là hàm hằng, mà <span class="math inline">\(g \circ f \simeq 1_X\)</span> nên <span class="math inline">\(X\)</span> co lại được.</p>
<p>Ngược lại, giả sử <span class="math inline">\(X\)</span> co lại được, tức là <span class="math inline">\(1_X \simeq c\)</span> với <span class="math inline">\(c: X \rightarrow X,\ c(x) = c_0\ \forall x \in X\)</span>. Xét <span class="math inline">\(f: X \rightarrow \{c_0\}\)</span> là hàm hằng và <span class="math inline">\(g: \{c_0\} \rightarrow X,\ g(c_0) = c_0\)</span>.</p>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/algebraic-topo-note-2</guid>
      <pubDate>Fri, 24 Feb 2023 18:28:16 +0700</pubDate>
    </item>
    <item>
      <title>VanVo - Ngôn ngữ lập trình với cú pháp thuần Việt</title>
      <link>https://balldk.github.io/posts/vanvo</link>
      <description>&lt;p&gt;Tất tần tật về ngôn ngữ lập trình VanVo (Văn Vở).&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<p>VanVo (Văn Vở) là ngôn ngữ lập trình được thiết kế với cú pháp thuần Việt, nhưng không chỉ đơn giản là dịch lại một cách gượng gạo từ các ngôn ngữ khác, mình cố gắng để thiết kế một ngôn ngữ sao cho các câu lệnh trông tự nhiên như tiếng Việt nhất có thể, thuận tiện cho người Việt nhất có thể. Điển hình là bạn có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</p>
<p>Ngôn ngữ sẽ có hơi thiên hướng toán học, những bạn học toán có thể sẽ cảm thấy quen thuộc hơn, vì mình định hướng ngôn ngữ được sử dụng như một CAS (Computer Algebra System). Tuy nhiên VanVo vẫn có thể dùng như một ngôn ngữ đa mục đích (General-purpose language) thông thường.</p>
<h2>Điểm qua một số tính năng của VanVo</h2>
<ul>
<li>Hỗ trợ những câu lệnh rẽ nhánh, cấu trúc lặp, cấu trúc dữ liệu và phép toán cơ bản.</li>
<li>Hỗ trợ phân số và số phức.</li>
<li>Có thể đặt tên định danh có khoảng trắng như <code>số nguyên tố</code>.</li>
<li>Không cần <code>;</code> ở cuối mỗi câu lệnh, và các khối lệnh sẽ được xác định bởi mức thụt dòng (indent level) như Python.</li>
<li>Phép nhân giữa hằng số, biến và mở ngoặc có thể lược bỏ, ví dụ <code>2x(x-1)</code> sẽ tương đương với <code>2*x*(x-1)</code>.</li>
<li>List comprehension như <code>{ n*m | n thuộc [1..10], m thuộc [1..10], n != m }</code></li>
<li>Lazy evaluation.</li>
<li>Các thao tác và phép toán trên tập hợp như hội, giao, hiệu, tích Descartes.</li>
<li>Gạch chân chính xác vị trí có lỗi khi chạy chương trình.</li>
</ul>
<h2>Một số ví dụ minh họa</h2>
<p><strong>Ví dụ 1:</strong> Xét tính chia hết của n cho 2 và 3, với n là các số nguyên trong khoảng <span class="math inline">\([1,100]\)</span></p>
<pre><code class="language-vanvo">cho A = [1..100]

với mỗi n thuộc A:
	nếu n % 2 == 0:
		xuất n, &quot;chia hết cho 2&quot;
	còn nếu n % 3 == 0:
		xuất n, &quot;chia hết cho 3&quot;
	còn không:
		xuất n, &quot;không chia hết cho cả 2 và 3&quot;
</code></pre>
<p><strong>Ví dụ 2:</strong> Tính giá trị của hàm hợp, với <span class="math inline">\((f.g)(x) = f(g(x))\)</span></p>
<pre><code class="language-vanvo">cho f(x) = 2x(x^2 - 2x)(3x - 5)
cho g(x) = 5x

cho a = 5
xuất f.g(a)
</code></pre>
<p><code>2x(x^2 - 2x)(3x - 5)</code> là cách viết ngắn gọn hơn của <code>2*x*(x^2 - 2*x)*(3*x - 5)</code>.</p>
<p><strong>Ví dụ 3:</strong> Sử dụng list comprehension để định nghĩa mảng vô hạn các phần tử, với <code>fib[i]</code> là phần tử thứ <code>i</code> trong dãy fibonacci</p>
<pre><code class="language-vanvo">cho fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuộc [3..] }

với mỗi n thuộc fib:
    xuất n
</code></pre>
<p>List comprehension có tính &ldquo;lazy&rdquo;,  tức là chỉ khi ta cần dùng phần tử nào trong mảng thì phần tử đó mới được tính ra, do đó ta có thể dễ dàng định nghĩa ra mảng vô hạn phần tử trong VanVo.</p>
<h2>Cài đặt</h2>
<p>Nếu bạn đã tải <a href="https://go.dev/">Go </a>thì cách đơn giản nhất để cài đặt là clone và build trực tiếp từ source như sau</p>
<pre><code class="language-bash">git clone https://github.com/balldk/vanvo
cd vanvo
go install .
</code></pre>
<p>Ngoài ra bạn có thể tải file thực thi tại đây <a href="https://github.com/balldk/vanvo/releases/tag/v0.1.0">Releases v0.1.0</a>.</p>
<h2>Cú pháp</h2>
<p><strong>Lưu ý</strong>: vì mình có sử dụng ligature font cho code trên web nên các kí hiệu như =&gt;, &gt;=, &lt;=, ==, != sẽ trở thành <code>=&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>.</p>
<h3>Quy định đặt tên và từ khóa</h3>
<p>Tên định danh là tên được bạn đặt cho biến và hàm trong chương trình, VanVo bao gồm các quy tắc đặt tên định danh như sau:</p>
<ul>
<li>Có thể chứa các kí tự <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>_</code> và toàn bộ bảng chữ cái cũng như dấu trong tiếng Việt.</li>
<li>Không được bắt đầu bằng một chữ số.</li>
<li>Khác với hầu hết các ngôn ngữ khác, VanVo cho phép bạn đặt tên định danh với khoảng trắng, nhưng có một lưu ý là khoảng trắng giữa các từ không quan trọng, ví dụ <code>nguyên tố</code> và <code>nguyên   tố </code> là hai tên định danh giống nhau.</li>
<li>Phân biệt hoa thường (case sensitive).</li>
<li>Không được đặt tên định danh trùng với từ khóa.</li>
</ul>
<p>Danh sách các từ khóa trong VanVo:</p>
<p><code>cho</code>, <code>thuộc</code>, <code>và</code>, <code>hay</code>, <code>với</code>, <code>với mỗi</code>, <code>nếu</code>, <code>còn nếu</code>, <code>còn không</code>, <code>đúng</code>, <code>sai</code>, <code>nhập</code>, <code>xuất</code></p>
<p><strong>Note:</strong> Bạn có thể viết các từ khóa không dấu, ví dụ <code>neu</code>, <code>voi</code> là các từ khóa hợp lệ. Tuy nhiên bạn chỉ có thể viết đầy đủ dấu hoặc là viết không dấu hoàn toàn, ví dụ <code>đung</code> không phải là một từ khóa hợp lệ vì thiếu dấu sắc.</p>
<h3>Khai báo biến</h3>
<p>Biến được định nghĩa thông qua từ khóa <code>cho</code>, với cấu trúc như sau</p>
<pre><code class="language-bnf">cho &lt;tên biến&gt; = &lt;biểu thức&gt;
</code></pre>
<p>Ví dụ</p>
<pre><code class="language-vanvo">cho x = 10.2
cho ngày sinh = 15
</code></pre>
<p>Một số hằng số được định nghĩa sẵn</p>
<pre><code class="language-vanvo">xuất Pi // 3.14159...
xuất E  // 2.71828...
</code></pre>
<h3>Khai báo hàm</h3>
<p>Khai báo hàm tương đối giống với khai báo biến</p>
<pre><code class="language-bnf">cho &lt;tên hàm&gt;(&lt;danh sách các tham số&gt;) = &lt;biểu thức&gt;
</code></pre>
<p>Ví dụ</p>
<pre><code class="language-vanvo">cho f(x,y,z) = 2x(x^2 - 2x + 1) - y^z
xuất f(100, 5, 3)
</code></pre>
<p>Ở ví dụ trên, hàm chỉ được định nghĩa ngắn gọn trong một hàng, để viết một số hàm phức tạp, cần thực hiện nhiều câu lệnh hơn, ta có thể dùng &ldquo;Biểu thức nhóm&rdquo;</p>
<pre><code class="language-vanvo">cho f(x) = (cho a = 5; cho b = 6; a+b+x)
xuất f(2) // 13
</code></pre>
<p>Biểu thức cuối cùng trong biểu thức nhóm sẽ là giá trị trả về cho toàn bộ biểu thức, ở ví dụ trên <code>a+b+x = 5+6+2 = 13</code> là giá trị của <code>f(2)</code></p>
<p>Trên thực tế ta sẽ xuống dòng tách các câu lệnh trong biểu thức nhóm</p>
<pre><code class="language-vanvo">// Trả về đúng, nếu n là số chẵn, sai nếu n là số lẻ
cho là chẵn(n) = (
	cho two = 2
	nếu n % two == 0:
		=&gt; đúng
	sai
)
</code></pre>
<p>Dấu suy ra <code>=&gt;</code> có ý nghĩa tương đương với câu lệnh <code>return</code> ở những ngôn ngữ khác, khi gặp <code>=&gt;</code> thì biểu thức nhóm sẽ kết thúc và trả về giá trị cho biểu thức</p>
<p>Một số hàm được định nghĩa sẵn</p>
<pre><code class="language-vanvo">xuất cos(Pi)  // -1
xuất sin(Pi)  // 0
xuất tan(Pi)  // 0
xuất E^ln(2)  // 2
</code></pre>
<h3>Các kiểu dữ liệu cơ bản</h3>
<pre><code class="language-vanvo">// Số nguyên
15
// số thực
3.14
// Phân số
3/14
// Số phức
3/2 - 2I
// Logic
đúng
sai
</code></pre>
<h3>Phép toán</h3>
<h4>Số học</h4>
<pre><code class="language-vanvo">cho a = 4
cho b = 5/2

xuất a + b  // 13/2
xuất a - b  // 3/2
xuất a * b  // 10
xuất a / b  // 8/5
xuất a ^ b  // 32
xuất a % 7  // 4
</code></pre>
<h4>Logic</h4>
<pre><code class="language-vanvo">xuất 1 == 2  // sai
xuất 1 != 2  // đúng
xuất 1 &lt; 1   // sai
xuất 1 &lt;= 1  // đúng
xuất 1 &gt; 1   // sai
xuất 1 &gt;= 1  // đúng

xuất đúng và sai  // sai
xuất đúng hay sai // đúng
</code></pre>
<h4>Toán tử ba ngôi</h4>
<p>Cấu trúc của toán tử ba ngôi</p>
<pre><code class="language-bnf">&lt;biểu thức 1&gt; nếu &lt;điều kiện&gt; còn không &lt;biểu thức 2&gt;
</code></pre>
<p>Nếu <code>&lt;điều kiện&gt;</code> thỏa thì toán tử ba ngồi sẽ trả về giá trị của <code>&lt;biểu thức 1&gt;</code>, còn không thì trả về giá trị của <code>&lt;biểu thức 2</code>&gt;. Ví dụ</p>
<pre><code class="language-vanvo">cho gtln(a, b) = a nếu a &gt; b còn không b
xuất gtln(2, 3)  // 3	
</code></pre>
<h3>Câu lệnh điều kiện</h3>
<p>Câu lệnh điều kiện có cấu trúc như sau</p>
<pre><code class="language-bnf">nếu &lt;điều kiện 1&gt;:
	...
còn nếu &lt;điều kiện 2&gt;:
	...
còn không:
	...
</code></pre>
<p><code>...</code> ở đây là khối lệnh, một khối lệnh được xác định bởi mức thụt dòng (indent level) của đoạn code. Không như Python, ở trong VanVo thì indent size được cố định là 4, tab cũng được chương trình mặc định hiểu là 4 spaces.</p>
<p>Ví dụ: xác định <code>n</code> là âm, dương hay 0</p>
<pre><code class="language-vanvo">cho n = 100

nếu n &lt; 0:
	xuất n, &quot;là số âm&quot;
còn nếu n &gt; 0:
	xuất n, &quot;là số dương&quot;
còn không:
	xuất n, &quot;là 0&quot;
</code></pre>
<h3>Cấu trúc lặp</h3>
<p>Trong VanVo có hai cấu trúc lặp là <code>với</code> và <code>với mỗi</code>, <code>với</code> có ý nghĩa tương đương với <code>while</code> ở những ngôn ngữ khác, còn <code>với mỗi</code> sẽ ý nghĩa tương tự như vòng lặp <code>for</code> nhưng không giống hoàn toàn mà sẽ có những đặc trưng riêng.</p>
<h4>Với</h4>
<p><code>với</code> có cấu trúc như sau</p>
<pre><code class="language-bnf">với &lt;danh sách điều kiện&gt;:
	...
</code></pre>
<p>Vòng lặp sẽ được thực hiện cho đến khi một trong các điều kiện của <code>&lt;danh sách điều kiện&gt;</code> không thỏa thì vòng lặp dừng lại.</p>
<p>Ví dụ: xuất ra các số trong khoảng <span class="math inline">\([0,100)\)</span></p>
<pre><code class="language-vanvo">cho i = 0
với 0 &lt;= i, i &lt; 100:
	xuất i
	i = i + 1
</code></pre>
<p>Điều kiện <code>0 &lt;= i, i &lt; 100</code> tương đương với <code>0 &lt;= i và i &lt; 100</code>. Ngoài ra bạn có thể sử dụng chaining comparison operator <code>0 &lt;= i &lt; 100</code> để ngắn gọn hơn.</p>
<h4>Với mỗi</h4>
<p><code>với mỗi</code> có cấu trúc như sau</p>
<pre><code class="language-bnf">với mỗi &lt;biến&gt; thuộc &lt;tập đếm được&gt;, &lt;ràng buộc&gt;,...:
	...
</code></pre>
<p>Hãy thử nhìn vào ví dụ trước nhé, chương trình sau sẽ xuất ra các số chẵn trong khoảng <span class="math inline">\([1,100]\)</span></p>
<pre><code class="language-vanvo">với mỗi n thuộc [1..100], x % 2 == 0:
	xuất n

// Output:
2
4
6
...
100
</code></pre>
<p>Ở chương trình trên, <code>n</code> lặp qua từng phần tử trong <code>[1..100]</code>, với <code>[1..100]</code> là tập các số nguyên trong khoảng từ 1 đến 100. Nếu <code>n</code> thỏa mọi ràng buộc được cho thì khối lệnh bên trong sẽ được thực hiện (trong trường hợp này thì ràng buộc là <code>n % 2 == 0</code>). Dĩ nhiên không phải tập hợp nào cũng có thể lặp qua được, phần tiếp theo sẽ giải thích vấn đề này chi tiết hơn.</p>
<p>Bạn có thể lặp qua nhiều tập và có nhiều ràng buộc cùng một lúc, lấy ví dụ</p>
<pre><code class="language-vanvo">với mỗi n thuộc [1..5], m thuộc [3..5], n % 2 == 0, m % 2 == 1:
	xuất n, m

// Output:
2 3
2 5
4 3
4 5
</code></pre>
<h3>Tập hợp</h3>
<p>Ban đầu khi mình phát thảo ý tưởng cho ngôn ngữ này thì mình lấy tập hợp, các phép toán và mệnh đề trên tập hợp làm tư tưởng chính. Nhưng càng về sau thì mình nhận ra là để xây dựng khái niệm tập hợp chuẩn thì tương đối không hiệu quả, và hầu hết các trường hợp thì mảng vẫn hữu dụng hơn, cho nên khái niệm mảng và tập hợp trong VanVo mình sẽ dùng trùng lặp nhau, bạn đọc nên hiểu hai khái niệm này trong VanVo là một, nhưng chúng không tương đương với khái niệm tập hợp thông thường.</p>
<p>Trong VanVo có những tập hợp được gọi là <strong>Tập đếm được</strong>, bạn có thể truy cập chỉ số (indexing) và lặp qua tập đếm được, những tập còn lại được gọi là <strong>Tập không đếm được</strong>. Sau đây là các loại tập hợp hiện có trong VanVo.</p>
<h4>Khoảng Thực (Real interval)</h4>
<p>Khoảng thực <span class="math inline">\([a,b]\)</span> là tập các số thực <span class="math inline">\(x\)</span> sao cho <span class="math inline">\(a\leq x \leq b\)</span>, bạn có thể dùng toán tử <code>thuộc</code> để xét xem một giá trị <span class="math inline">\(x\)</span> có thuộc vào một tập hay không, lấy ví dụ</p>
<pre><code class="language-vanvo">cho A = [0,5]

xuất 2 thuộc A    // đúng
xuất 5 thuộc A    // đúng
xuất -1 thuộc A   // sai
xuất I thuộc A    // sai
</code></pre>
<p>Khoảng thực là Tập không đếm được.</p>
<h4>Khoảng đều</h4>
<p>Khoảng đều <span class="math inline">\([a..b]\)</span> là tập các số <span class="math inline">\(n\)</span> sao cho <span class="math inline">\(a \leq n \leq b\)</span>, và các phần tử liên tiếp cách nhau đúng một đơn vị, lấy ví dụ</p>
<pre><code class="language-vanvo">cho a = 1.2
cho b = 5
cho A = [a..b]

với mỗi x thuộc A:
	xuất x

xuất b thuộc A

// Output:
1.2
2.2
3.2
4.2
sai
</code></pre>
<p>Từ ví dụ trên ta có thể nhận thấy Khoảng đều là một Tập đếm được.</p>
<p>Bạn có thể đặt bước nhảy (step) cho một Khoảng với cú pháp <code>[a..b, step]</code>, ví dụ</p>
<pre><code class="language-vanvo">với mỗi n thuộc [0..4, 2]:
	xuất n

// Output:
0
2
4
</code></pre>
<h4>Danh sách (List)</h4>
<p>Danh sách sẽ tương đối giống mảng thông thường ở những ngôn ngữ khác, với cú pháp <code>{a, b, c, ...}</code>, ví dụ</p>
<pre><code class="language-vanvo">cho A = {1, 2, &quot;hello&quot;, đúng}

với mỗi phần tử thuộc A:
	xuất phần tử

// Output:
1
2
&quot;hello&quot;
đúng
</code></pre>
<h4>List comprehension</h4>
<p>Mình cũng không rõ phải dịch khái niệm này ra như thế nào, nhưng riêng trong VanVo thì list comprehension sẽ có cấu trúc giống y như cách chúng ta biểu diễn tập hợp trong toán</p>
<pre><code class="language-bnf">{ &lt;biểu thức&gt; | &lt;biến&gt; thuộc &lt;tập đếm được&gt;, &lt;ràng buộc&gt; }
</code></pre>
<p>Có thể thấy cấu trúc của list comprehension và vòng lặp &ldquo;với mỗi&rdquo; có sự tương đồng nhất định, vì chúng thật sự có cơ chế gần giống nhau, ta có thể hiểu <code>&lt;biểu thức&gt;</code> ở đây là phần thân của vòng lặp, và giá trị của <code>&lt;biểu thức&gt;</code> sẽ là từng phần tử trong tập trên.</p>
<p>Ví dụ: Xây dựng tập các số nguyên dương chẵn</p>
<pre><code class="language-vanvo">cho A = { n | n thuộc [1..], n % 2 == 0 }
</code></pre>
<p>Hoặc đơn giản hơn là</p>
<pre><code class="language-vanvo">cho A = { 2n | n thuộc [1..] }
</code></pre>
<p>Bạn có thể nghi ngờ rằng khi chạy câu lệnh trên thì chương trình bị vướng vào vòng lặp vô hạn và không thể chạy tiếp những câu lệnh khác, nhưng thực tế thì chương trình vẫn tiếp tục chạy những câu lệnh tiếp theo, bạn có thể thao tác trên <code>A</code>, hay lấy ra bất kì phần tử nào trong tập <code>A</code> đó mà bạn muốn. Lý do ta có thể làm được việc này là vì VanVo có hỗ trợ lazy evaluation cho list comprehension, chỉ khi bạn cần phần tử nào thì chương trình mới tính ra phần tử đó (và các phần tử trước) rồi lưu lại. Vì vậy ta có thể dễ dàng định nghĩa ra mảng vô hạn các phần tử trong VanVo.</p>
<h4>Các thao tác và phép toán trên tập hợp</h4>
<p><strong>Lực lượng (#)</strong>: Hiện tại chỉ có thể lấy lực lượng (số phần tử) trên Tập đếm được</p>
<pre><code>cho A = [1..100, 2]
cho B = {3, 5, 7}

#A      // 50
#B      // 3
#(A-B)  //
</code></pre>
<p><strong>Chỉ số:</strong> Tương tự, chỉ có Tập đếm được mới có chỉ số</p>
<pre><code>cho A = [1..100, 2]
cho fib = {0, 1, 1} + { fib[n-1] + fib[n-2] | n thuoc [3..] }

A[1]     // 3
fib[50]  // 12586269025
</code></pre>
<p><strong>Phép hội (+)</strong>: Đối với trường hợp lấy hội 2 Tập đếm được thì ta hiểu đây là phép hợp nối mảng sẽ chính xác hơn</p>
<pre><code class="language-vanvo">cho A = {1, 2} + [6..10]  // {1, 2, 6, 7, 8, 9, 10}
cho B = {1, 2} + [6, 10]  // B là Tập không đếm được

8.2 thuộc B  // đúng
</code></pre>
<p><strong>Phép hiệu (-)</strong></p>
<pre><code class="language-vanvo">cho A = [1..9] - [4, 6]  // {1, 2, 3, 7, 8, 9}
cho B = [1, 9] - [4, 6]  // B là Tập không đếm được

7 thuộc B  // đúng
</code></pre>
<p><strong>Tích Descartes (*)</strong></p>
<pre><code class="language-vanvo">cho A = [1..3]
cho B = [1..3]

A*B
// { {1, 1}, {1, 2}, {1, 3}, 
//   {2, 1}, {2, 2}, {2, 3},
//   {3, 1}, {3, 2}, {3, 3} }
</code></pre>
<h2>Túm cái váy</h2>
<p>Hiện tại ngôn ngữ vẫn còn sơ khai và sẽ còn nhiều thay đổi trong thời gian tới, nhìn chung thì dự án này cũng chỉ là sở thích cá nhân thôi, mình không có ý định tạo ra với mục đích thay thế bất kì ngôn ngữ nào trên thị trường cả nên các bạn có ý kiến đóng góp hay ý tưởng gì thì cồm men bên dưới nhẹ nhàng hoặc có thể tạo issue trên github nhé.</p>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/vanvo</guid>
      <pubDate>Thu, 18 Aug 2022 18:06:33 +0700</pubDate>
    </item>
    <item>
      <title>Góc nhìn khác về tail call elimination</title>
      <link>https://balldk.github.io/posts/interesting-tail-call-elimination-problem</link>
      <description>&lt;p&gt;Một bài toán thú vị về tối ưu đệ quy giúp tui có góc nhìn khác về tail call elimination như thế nào.&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<p>Tui thì đó giờ hay cày rank trên <a href="https://www.codewars.com">Codewars</a>, chủ yếu là vì giao diện của nó ngầu lòi hơn ba mấy web thuật toán chán ngắt khác 😄 Chơi một thời gian thì tui cũng lên được 4 kyu và gặp phải bài toán này <a href="https://www.codewars.com/kata/57040e445a726387a1001cf7">The fusc function - Part 2</a>. Bài này thú vị ở chỗ, thay vì như thông thường họ chỉ đưa mình đề bài, thì bài này họ còn đưa cho mình một bài khác ví dụ mẫu cho phương pháp mà họ muốn mình dùng. Nói chung là giải xong sẽ học được phương pháp gì đó mới, chỉ tiếc là tui lúc đó đã quyết định gập máy đi ngủ 🙂 Mới đầu năm nay thì tui thử mở ra làm lại, và congrats, não tui đã được thông, giờ tui đi thông ngược lại cho mấy bạn đây.</p>
<p>Trong bài viết này, tui sẽ đi giải quyết bài toán trên trước, mục tiêu bài toán là đưa từ một hàm đệ quy thành một hàm đệ quy đuôi (tail call elimination), đừng lo, tui sẽ giải thích kĩ hơn những thuật ngữ này ở phía dưới. Sau đó tui sẽ chia sẻ một chút về góc nhìn của tui tại sao phương pháp của bài toán này khá độc đáo so với thực tế. Okay triển thôi nào!</p>
<h2>Nội dung bài toán</h2>
<p>Dành cho những con người chây lười không chịu bấm vào link đọc trước (ừa tui đang nói bạn đó) thì tui sẽ trình bày lại bài toán ở đây luôn, <del>chứ không phải vì tui muốn bài mình dài ra đâu nha</del>. Với lại tui cũng sẽ làm rõ một số chỗ mà bài viết gốc không đề cập tới.</p>
<p>Cho hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> được định nghĩa như sau:</p>
<p><span class="math display">\[\begin{cases}
\operatorname{fusc}(0) = 0\\
\operatorname{fusc}(1) = 1\\
\operatorname{fusc}(2n) = \operatorname{fusc}(n)\\
\operatorname{fusc}(2n + 1) = \operatorname{fusc}(n) + \operatorname{fusc}(n + 1)\\
\end{cases}
\]</span></p>
<p>Việc của bạn là hãy viết lại và tối ưu hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> trên. Nhớ rằng <span class="math inline">\(n\)</span> sẽ có giá trị rất lớn, cụ thể thì <span class="math inline">\(n\)</span> sẽ lớn hơn 1000 bit (đối với Javascript) và 52 bit (đối với PHP), nên là cần lưu ý tới vấn đề stack overflow và timeouts.</p>
<h2>Gợi ý phương pháp</h2>
<blockquote>
Phần này trong lúc đọc mấy bạn không cần quá hoang mang những thứ như là tại sao phải đưa hai vế về cùng dạng, rồi tại sao phải đặt thêm biến a, b các thứ đâu, cứ đọc đến cuối là mọi thứ sẽ trở nên make sense thôi.
</blockquote>
<p>Tưởng tượng thay vì đề bài là hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> mà là hàm <span class="math inline">\(\operatorname{fib}(n)\)</span> (trả về <a href="https://en.wikipedia.org/wiki/Fibonacci_number">số Fibonacci</a> thứ <span class="math inline">\(n\)</span>), thì lúc này hàm được định nghĩa như sau:</p>
<p><span class="math display">\[\begin{cases}
\operatorname{fib}(0) = 1 & (1)\\
\operatorname{fib}(1) = 1 & (2)\\
\operatorname{fib}(n + 2) = \operatorname{fib}(n) + \operatorname{fib}(n + 1)\quad (n \geq 0) & (3)
\end{cases}
\]</span></p>
<p>Nếu dùng trực tiếp định nghĩa trên thì không được tối ưu cho lắm. Dĩ nhiên bạn hoàn toàn có thể dùng quy hoạch động, nhưng làm vậy thì lại tốn thêm bộ nhớ không cần thiết, nên là chúng ta sẽ cố thử tìm đệ quy đuôi (<a href="https://www.geeksforgeeks.org/tail-recursion">tail recursion</a>) cho bài toán này.</p>
<blockquote>Lại là góc nhỏ cho những con lười không chịu bấm vào đọc trước định nghĩa của tail recursion đây, thì tail recursion là loại hàm đệ quy mà việc gọi đệ quy là điều cuối cùng hàm đó thực hiện. Lấy ví dụ:</blockquote>
<pre><code class="language-js">// Đây không là tail recursion vì sau khi gọi đệ quy
// fact(n-1) thì hàm phải thực hiện thêm phép nhân
// với n nữa mới kết thúc
function fact(n) {
    if (n === 1)
        return 1
    else
        return n * fact(n-1)
}

// Đây là tail recursion vì chỉ cần gọi fact(n-1, acc*n)
// xong thì hàm sẽ kết thúc
function fact(n, acc) {
    if (n === 1)
        return acc
    else
        return fact(n-1, acc*n)
}
</code></pre>
<p>Bạn có thể tự tìm hiểu kĩ hơn tại sao khi đưa về tail recursion thì sẽ tối ưu hơn, nhưng để nói sơ qua thì bình thường khi bạn gọi đệ quy, những giá trị, ô nhớ các thứ ở hiện tại sẽ được đẩy lên call stack, cứ mỗi lần gọi đệ quy lồng nhau thì call stack sẽ càng ngày càng cao lên, bộ nhớ phình to ra, cho đến khi vượt quá call stack size thì chương trình trả về lỗi stack overflow. Tail recursion thì lại khác, vì đệ quy là câu lệnh được thực hiện cuối cùng nên compiler sẽ thoải mái giải phóng stack hiện tại vì nó chắc chắn stack hiện tại không cần dùng nữa, nên dù có gọi đệ quy vô hạn lần thì cũng không lo bị stack overflow.</p>
<p>Tiếp tục nhé, bây giờ để biến <span class="math inline">\(\operatorname{fib}(n)\)</span> thành tail recursion, ta lấy phương trình <span class="math inline">\((3)\)</span> đem biến đổi thử, và chúng ta muốn sau khi biến đổi xong thì vế phải phải có dạng giống na ná vế trái, từ đó ta có thể định nghĩa một hàm phụ <span class="math inline">\(F\)</span> nào đó sao cho vế trái và vế phải phụ thuộc vào nhau thông qua <span class="math inline">\(F\)</span>, kiểu như <span class="math inline">\(F(2n) = F(3n-1)\)</span> chẳng hạn. Rồi vậy ta thử cộng <span class="math inline">\(\operatorname{fib}(n+1)\)</span> vào hai vế xem sao:</p>
<p><span class="math display">\[\operatorname{fib}(n+1) + \operatorname{fib}(n+2) = \operatorname{fib}(n) + 2\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Hai vế khá giống nhau rồi đó, <span class="math inline">\(\operatorname{fib}(n+1)\)</span> (vế trái) tương ứng với <span class="math inline">\(\operatorname{fib}(n)\)</span> (vế phải) là ổn rồi nè, còn <span class="math inline">\(\operatorname{fib}(n+2)\)</span> (vế trái) tương ứng với <span class="math inline">\(\operatorname{fib}(n+1)\)</span> (vế phải) thì vẫn chưa ổn vì bị khác hệ số, để khắc phục chuyện này thì ta sẽ đưa ra một biến khác, gọi là biến <span class="math inline">\(b\)</span> đi. Giờ ta thử cộng <span class="math inline">\((b-1)\operatorname{fib}(n+2)\)</span> vào hai vế xem sao (mục đích cộng như vậy là để <span class="math inline">\(\operatorname{fib}(n+2)\)</span> có hệ số là <span class="math inline">\(b\)</span>):</p>
<p><span class="math display">\[\operatorname{fib}(n+1) + b\cdot \operatorname{fib}(n+2) = b\cdot \operatorname{fib}(n) + (b+1)\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Ta nhận thấy hệ số của <span class="math inline">\(\operatorname{fib}(n+1)\)</span> và <span class="math inline">\(\operatorname{fib}(n)\)</span> chưa giống nhau (bên là <span class="math inline">\(1\)</span>, bên là <span class="math inline">\(b\)</span>), nên là ta đưa thêm biến <span class="math inline">\(a\)</span> vào và làm tương tự, ta được:</p>
<p><span class="math display">\[a\cdot \operatorname{fib}(n+1) + b\cdot \operatorname{fib}(n+2) = b\cdot \operatorname{fib}(n) + (a+b)\cdot \operatorname{fib}(n + 1)\tag{4}
\]</span></p>
<p>Tuyệt vời ông mặt trời, hai bên có cùng một dạng rồi đó, bây giờ ta định nghĩa hàm phụ <span class="math inline">\(F\)</span> như sau:</p>
<p><span class="math display">\[F(a, b, n) = a\cdot \operatorname{fib}(n) + b\cdot \operatorname{fib}(n+1)
\]</span></p>
<p>Từ đó ta có thể biểu diễn hai vế của <span class="math inline">\((4)\)</span> dưới dạng:</p>
<p><span class="math display">\[F(a, b, n+1) = F(b, a+b, n) \tag{*}
\]</span></p>
<p>Ngoài ra dựa vào định nghĩa của <span class="math inline">\(F\)</span>, ta được:</p>
<p><span class="math display">\[F(a, b, 0) = a\cdot \operatorname{fib}(0) + b\cdot \operatorname{fib}(1) = a + b \tag{5}
\]</span></p>
<p>Hơn nữa:</p>
<p><span class="math display">\[\operatorname{fib}(n) = 1\cdot \operatorname{fib}(n) + 0\cdot \operatorname{fib}(n+1) = F(1, 0, n) \tag{6}
\]</span></p>
<p>Ta đã hoàn toàn có đủ nguyên liệu để triển khai thuật toán rồi đó, để ý:</p>
<ul>
<li><span class="math inline">\((6)\)</span> cho ta được định nghĩa tổng quát của <span class="math inline">\(\operatorname{fib}(n)\)</span> dựa trên hàm phụ <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((*)\)</span> cho ta công thức đệ quy của <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((5)\)</span> cho ta base case đệ quy của <span class="math inline">\(F\)</span>.</li>
</ul>
<p>Hy vọng tới đây mọi thứ make sense được với bạn, nếu lú thì cũng không sao cứ đọc lại nhé, mấy lần đầu mình đọc cũng lú 🙂 Giờ thì code thôi (2 code dưới này đều là của tác giả bài toán hết nha, không phải của tui):</p>
<pre><code class="language-python">def fib(n):

    def F(a, b, n):
        if n == 0: return a + b    # see (5) above
        return F(b, a + b, n - 1)  # see (*) above

    return F(1, 0, n)              # see (6) above
</code></pre>
<p>Tới đây là <span class="math inline">\(QED\)</span> rồi, nhưng nếu ngôn ngữ bạn dùng không hỗ trợ tối ưu đệ quy đuôi (<a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">tail call optimization</a>) thì bạn có thể implement theo dạng khử đệ quy như sau:</p>
<pre><code class="language-python">def fib(n):
    a, b = 1, 0                    # see (6) above
    while n &gt; 0:
        a, b, n = b, a + b, n - 1  # see (*) above
    return a + b .                 # see (5) above
</code></pre>
<blockquote>
Đây là một sức mạnh khác của tail recursion, một khi bạn đã đưa hàm về tail recursion rồi thì việc khử đệ quy là vô cùng đơn giản.
</blockquote>
<p>Tuyệt dời, làm &ldquo;tương tự&rdquo; với hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> thôi nào 😉. Nếu đọc tới đây mà bạn đã có ý tưởng, hoặc muốn thử sức bản thân thì có thể pause lại. Thật ra theo tui thì một khi đã nắm được ý tưởng của phương pháp này rồi thì cũng không quá khó đâu.</p>
<h2>Giải quyết bài toán</h2>
<p>Nhắc lại định nghĩa của hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span>. Để cho <del>gõ đỡ mỏi tay</del> đơn giản thì tui đặt hàm <span class="math inline">\(\operatorname{fusc}(n)\)</span> là hàm <span class="math inline">\(f(n)\)</span> luôn nhé:</p>
<p><span class="math display">\[\begin{cases}
f(0) = 0 & (1)\\
f(1) = 1 & (2)\\
f(2n) = f(n) & (3)\\
f(2n + 1) = f(n) + f(n + 1) & (4)\\
\end{cases}
\]</span></p>
<p>Tương tự như ví dụ trên, từ định nghĩa ta sẽ cố gắng tìm phương trình nào đó sao cho hai vế có cùng dạng, rồi từ đó đặt hàm phụ. Lấy <span class="math inline">\((3)\)</span> và <span class="math inline">\((4)\)</span> cộng lại với nhau thử coi sao:</p>
<p><span class="math display">\[f(2n)+f(2n+1)=2f(n) + f(n+1)
\]</span></p>
<p>Thấy hai vế cũng na ná giống rồi nè, <span class="math inline">\(f(2n)\)</span> tương ứng với <span class="math inline">\(f(n)\)</span> và <span class="math inline">\(f(2n+1)\)</span> tương ứng với <span class="math inline">\(f(n+1)\)</span>. Bây giờ tìm cách cân bằng hệ số thôi. Cụ thể, ta sẽ đưa biến <span class="math inline">\(b\)</span> vào phương trình bằng cách cộng <span class="math inline">\((b-1)f(2n+1)\)</span> hai vế, ta được:</p>
<p><span class="math display">\[f(2n)+bf(2n+1)=(b+1)f(n) + bf(n+1)
\]</span></p>
<p>Tương tự, đưa biến <span class="math inline">\(a\)</span> vào phương trình:</p>
<p><span class="math display">\[af(2n)+bf(2n+1)=(a+b)f(n) + bf(n+1) \tag{5}
\]</span></p>
<p>Hai vế đã cùng dạng như mình ao ước rồi đó, giờ định nghĩa hàm phụ <span class="math inline">\(F\)</span> thôi:</p>
<p><span class="math display">\[F(a, b, n) = af(n) + bf(n+1)
\]</span></p>
<p>Từ đó ta biểu diễn <span class="math inline">\((5)\)</span> theo <span class="math inline">\(F\)</span> như sau:</p>
<p><span class="math display">\[F(a,b,2n) = F(a+b,b,n) \tag{*}
\]</span></p>
<p>Ngoài ra từ định nghĩa của <span class="math inline">\(F\)</span> suy ra được:</p>
<p><span class="math display">\[F(a,b,0) = af(0) + bf(1) = b \tag{6.1}
\]</span></p>
<p>Và:</p>
<p><span class="math display">\[F(a,b,1) = af(1) + bf(2) = a + b \tag{6.2}
\]</span></p>
<p>Hơn nữa:</p>
<p><span class="math display">\[f(n) = 1f(n) + 0f(n+1) = F(1,0,n) \tag{7}
\]</span></p>
<p>Ngừng lại một chút, tới đây ta vẫn chưa thể triển khai thành thuật toán hoàn chỉnh được, tại sao ư? Để ý <span class="math inline">\((*)\)</span> chỉ được định nghĩa với <span class="math inline">\(2n\)</span>, tức khi input là số chẵn, vậy còn lẻ thì sao? Đơn giản thôi, thế trường hợp input lẻ vào <span class="math inline">\(F\)</span> rồi biến đổi, tức là:</p>
<p><span class="math display">\[\begin{align*}
F(a,b,2n+1)
&= af(2n+1) + bf(n+1)\\
&= a[f(n) + f(n+1)] + bf(n+1)\\
&= af(n) + (a+b)f(n+1)\\
&= F(a,a+b,n) \tag{**}
\end{align*}
\]</span></p>
<p>Ta tổng hợp lại được như sau:</p>
<ul>
<li><span class="math inline">\((7)\)</span> cho ta định nghĩa tổng quát của <span class="math inline">\(f(n)\)</span> dựa trên <span class="math inline">\(F\)</span>.</li>
<li><span class="math inline">\((*)\)</span> cho ta công thức đệ quy của <span class="math inline">\(F\)</span> đối với trường hợp input chẵn, tương tự với <span class="math inline">\((**)\)</span> ở trường hợp input lẻ.</li>
<li><span class="math inline">\((6.1)\)</span> và <span class="math inline">\((6.2)\)</span> cho ta base case đệ quy của <span class="math inline">\(F\)</span>.</li>
</ul>
<p>Code thoai:</p>
<pre><code class="language-js">function fusc(n) {

    function F(a, b, k) {
        if (k === 0)  // See (6.1)
            return b
        else if (k === 1)  // See (6.2)
            return a + b
        else if (k % 2 === 0)  // See (*)
            return F(a+b, b, Math.round(k / 2))
        else  // See (**)
            return F(a, a+b, Math.round((k-1) / 2))
    }

    return F(1, 0, n)  // See (7)
}
</code></pre>
<p>Submit thử:<br>
<img src="https://i.imgur.com/yoKDKTn.png" alt="submit-code-img"><br>
Ngon lành chứ hả, bonus cho mấy bạn thêm code Haskell nè:</p>
<pre><code class="language-haskell">fusc :: Integer -&gt; Integer
fusc n = aux 1 0 n
  where
    aux _ b 0 = b
    aux a b 1 = a+b
    aux a b n
      | even n = aux (a+b) b (n `div` 2)
      | otherwise = aux a (a+b) ((n-1) `div` 2)
</code></pre>
<p>Tui biết có một số bạn đọc tới đây rồi thì ngứa lắm, có thể bạn sẽ thắc mắc tại sao không dùng quy hoạch động? Thì đầu tiên là tui đang muốn nhấn mạnh về phương pháp này, nên quy hoạch động không nằm trong khuôn khổ của bài viết. Thứ 2 là quy hoạch động thật ra cũng không hiệu quả bằng đâu, tui cũng có thử implement quy hoạch động xong submit thử rồi nhưng nó tốn quá nhiều bộ nhớ, codewars không accept (người ta tính hết rồi ^^).</p>
<h2>Góc nhìn của tui về phương pháp này</h2>
<p>Trong pure functional programming language (FP) như Haskell thì không có vòng lặp cho bạn dùng, thay vào đó nếu bạn muốn lặp thì bạn phải xây dựng đệ quy. Mà thực tế có những tính năng bạn cần lặp vô hạn hoặc lặp rất nhiều lần, để không bị stack overflow trên những tính năng đó thì họ phải hướng tới tail recursion. Vậy làm sao để xây dựng tail recursion? ừa thì linh cảm, tâm linh là chính thôi, lấy ví dụ cho hàm tính giai thừa:</p>
<pre><code class="language-js">// Đệ quy thông thường
function fact(n) {
    if (n === 1)
        return 1
    else
        return n * fact(n-1)
}

// Tail recursion
function fact(n, acc) {
    if (n === 1)
        return acc
    else
        return fact(n-1, acc*n)
}
fact(10, 1) // tính 10!
</code></pre>
<p>Hàm đệ quy thông thường thì đơn giản rồi mình sẽ không nhắc tới nhé. Còn phần tail recursion ở dưới mình có thể hiểu là ta cần 1 biến nhân dồn kết quả lại, gọi là <code>acc</code> (accumulator). <code>acc</code> có giá trị ban đầu là 1, mỗi lần gọi đệ quy thì ta nhân <code>n</code> vô <code>acc</code>, đồng thời giảm <code>n</code> xuống một đơn vị, rồi truyền vào đệ quy kế tiếp. Cứ truyền xuống như vậy, lúc này bạn sẽ thấy <code>acc</code> mang giá trị của tích <code>n(n-1)(n-2)...</code> và cũng là kết quả mình cần tìm khi <code>n</code> giảm xuống 1.</p>
<p>Đây cũng là pattern chung trong phương pháp tìm tail recursion, ta sẽ có biến tích luỹ <code>acc</code> là tham số được truyền dần xuống, và nó sẽ đem theo kết quả cho đến khi chạm base case. Nhưng ta có thể thấy pattern trên chỉ do mình cảm giác và tưởng tượng (aka tâm linh) chứ không được chứng minh rõ ràng, và ban đầu mình cũng nghĩ mấy thứ này không thể chứng minh được cho đến khi gặp bài toán xịn xò mà mình đã giải quyết bên trên.</p>
<blockquote>
Góc bài tập về nhà: Bạn có thể thử suy nghĩ cách chứng minh định nghĩa hàm fact(n, acc) bên trên là đúng dựa trên phương pháp chặt chẽ của bài viết. Và xây dựng lại tail recursion cho fib(n) dựa trên phương pháp tâm linh này, bạn sẽ bất ngờ vì nó cho cùng một kết quả đó.
</blockquote>
<p>Cảm ơn mấy bạn đã đọc hết đến đây (hoặc là do bạn lướt xuống và gặp được dòng này). Đây là bài viết đầu tiên trên blog của tui, tui xin nhận mọi ý kiến đóng góp, nhưng nếu bạn có ý định ném đá thì nên cân nhắc lời lẽ phù hợp với trái tim mỏng manh của tác giả 😢.</p>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/interesting-tail-call-elimination-problem</guid>
      <pubDate>Wed, 01 Sep 2021 20:31:32 +0700</pubDate>
    </item>
    <item>
      <title>TODO List cho tính năng của blog</title>
      <link>https://balldk.github.io/posts/TODO</link>
      <description>&lt;p&gt;Một số tính năng tui (đã / đang / muốn / sẽ) triển khai cho góc nho nhỏ thân yêu này, mọi người có ý tưởng hay đóng góp gì thì có thể comment&amp;hellip;&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<p>Một số tính năng tui (đã / đang / muốn / sẽ) triển khai cho góc nho nhỏ thân yêu này, mọi người có ý tưởng hay đóng góp gì thì có thể comment phía dưới nhé 🥺 <del>(tui thích hay không thì còn tuỳ)</del></p>
<h2>General</h2>
<ul class="task-list">
<li><input checked="" disabled="" type="checkbox"> 404 redirect page</li>
<li><input checked="" disabled="" type="checkbox"> Add some important meta tags</li>
<li><input disabled="" type="checkbox"> Dark theme</li>
<li><input checked="" disabled="" type="checkbox"> RSS<br>
Cũng không biết có nên làm cái này không, tại tui thấy ít người dùng cái này quá.</li>
</ul>
<h2>Homepage</h2>
<ul class="task-list">
<li><input disabled="" type="checkbox"> Hashtag filter</li>
<li><input disabled="" type="checkbox"> Post search</li>
<li><input disabled="" type="checkbox"> Paging<br>
Phân trang danh sách bài viết, cái này chắc đợi viết được nhiều bài rồi thêm vô cũng được.</li>
</ul>
<h2>Post renderer</h2>
<ul class="task-list">
<li><input checked="" disabled="" type="checkbox"> Default markdown</li>
<li><input checked="" disabled="" type="checkbox"> Latex</li>
<li><input checked="" disabled="" type="checkbox"> Auto generate table of content</li>
<li><input checked="" disabled="" type="checkbox"> AST Transformer: Add class name for task list</li>
</ul>
<h2>Post interface</h2>
<ul class="task-list">
<li><input checked="" disabled="" type="checkbox"> Display table of content<br>
Chức năng này là tui <del>ăn cắp</del> mượn ý tưởng từ tiền bối nè, mà tiền bối bỏ luôn vụ này rồi, đang suy nghĩ không biết có nên bỏ luôn không :))</li>
<li><input checked="" disabled="" type="checkbox"> Zoom image when click</li>
<li><input disabled="" type="checkbox"> Post reactions (Like, Heart, Wow, Confuse, Angry)<br>
Tui tính làm giống FB luôn, để nút reaction ở góc dưới phải bài viết, lúc người dùng hover vào thì hiện danh sách reaction ra.</li>
<li><input checked="" disabled="" type="checkbox"> Post read time</li>
<li><input checked="" disabled="" type="checkbox"> Code highlight</li>
</ul>
<h2>Post editor page for admin</h2>
<p>Tui lười làm cái này quá, toàn viết post trên app, xong copy nội dung rồi gửi request lên server thôi :))</p>
<h2>Comment Section</h2>
<ul class="task-list">
<li><input checked="" disabled="" type="checkbox"> Login to comment (Github, Google)
<ul class="task-list">
<li><input disabled="" type="checkbox"> Fix Github login on mobile</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> With reply</li>
<li><input checked="" disabled="" type="checkbox"> Recaptcha v3<br>
Chống nắc cơ, sợ lắm :((</li>
<li><input disabled="" type="checkbox"> Comment level tracking<br>
Nói thiệt là tui cũng không biết phải gọi chức năng này là gì :)) Nhưng đại loại là cái thanh chỉa nhánh phân cấp comment giống chức năng mới của FB á.</li>
<li><input disabled="" type="checkbox"> Paging</li>
</ul>
<h2>Development aspects</h2>
<ul class="task-list">
<li><input checked="" disabled="" type="checkbox"> Containerize project with Docker for Cloud Run deployment</li>
</ul>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/TODO</guid>
      <pubDate>Tue, 31 Aug 2021 20:31:20 +0700</pubDate>
    </item>
    <item>
      <title>Tui là ai, đây là đâu?</title>
      <link>https://balldk.github.io/posts/about</link>
      <description>&lt;p&gt;Đôi lời về bản thân và blog của tui&lt;/p&gt;&#xA;</description>
      <content:encoded><![CDATA[<h2>Tui là ai?</h2>
<p>Tui hiện đang là sinh viên quèn tại khoa toán trường Đại học Khoa học tự nhiên - TPHCM. Xuất thân là dân tin, đam mê và bắt đầu học lập trình từ sớm so với bạn bè đồng trang lứa, đã từng kinh qua nhiều món như Web dev, App dev, Blockchain, CP,&hellip;. Với khả năng cũng như đam mê cháy bỏng ấy, tui đã quyết định theo đuổi sự nghiệp&hellip;&hellip;..học toán và làm toán 🙂 (còn lý do thì chắc phải dành riêng cho một bài viết khác). Tui hiện tại thì mong muốn tương lai được làm nghiên cứu về toán, toán gì thì tui chưa dám xác định, một phần là vì thấy hướng nào cũng hay ho hết, phần lớn còn lại thì vì trình còn gà quá &#x1f622;.</p>
<h2>Đây là đâu?</h2>
<p>Đây là góc nhỏ để tui bày tỏ, chém gió, chia sẻ kiến thức và cuộc sống của tui với mọi người. Có lẽ tui sẽ viết chủ yếu về toán và tin (tất nhiên, ngành tui học mà 🙂), tui nghĩ việc chia sẻ kiến thức cho người khác, đồng thời tổng hợp lại thành một bài viết có cấu trúc là một cách hiệu quả để tui review và trau dồi lại kiến thức, <del>đấy là người ta sẽ nói thế chứ tui chủ yếu muốn loè mắt mọi người thôi</del>. Ngoài ra thì tui cũng muốn kiếm thêm nguồn động lực để học nữa, chứ tui lười lắm &#x1f62d;.</p>
<h3>Lịch sử của blog</h3>
<p>Như các tiền bối IT đã từng nói, muốn viết blog thì hãy tập trung vào nội dung, đừng tập trung code hẳn một cái blog, vì tới lúc code xong thì bạn đã hết hứng viết nội dung rồi. Biết trước được điều đó, nên tui đã quyết định&hellip;&hellip;..dành toàn bộ khoảng hè ngắn ngủi năm 2021 để code hẳn một cái blog, và thế là &ldquo;Góc nhỏ của <span class="math inline">\(\overrightarrow{K}\)</span>&rdquo; ra đời 🙂.</p>
<h3>Tại sao không viết blog trên nền tảng có sẵn mà lại code từ đầu?</h3>
<ol>
<li>Vì nó có ích<br>
Ngoài những lý do sến súa sướt mướt mà tui viết blog bên trên, thì blog này cũng là một side project để tui khè với nhà tuyển dụng, nếu tui có ý định đi code thuê.</li>
<li>Vì nó vui<br>
Code là chân lý, cứ được code là vui rồi, không cần lý do nhé 🙂.</li>
<li>Dễ Customize<br>
Đây có lẽ là lý do chính, tui đã từng thử dùng qua nhiều nền tảng viết blog như wordpress, ghost, blogspot,&hellip; các thứ rồi. Dùng rất dễ nhưng để thêm tính năng mà tui muốn thì rất khó, hoặc thậm chí là không thể (hoặc là do tui gà). Mà định hướng tui tính sẽ đưa những dự án mô phỏng vô nữa, cần độ custom cao. Hoặc bạn có thể thấy trực tiếp trên blog là tui khá chú trọng làm animation để tăng UX cho web. Nên tui nghĩ tự code cho mình một quả blog là một định hướng tốt.</li>
<li>Học được nhiều thứ<br>
Cụ thể thì tui học được cách:</li>
</ol>
<ul>
<li>Chửi máy tính mình đang dùng trong khi lỗi là ở framework (I mean you Nuxt).</li>
<li>Kìm chế cảm xúc khi debug cả ngày trời nhưng tới cuối ngày thì phát hiện ra là mình viết sai chính tả.</li>
</ul>
<ol start="5">
<li><del>Vì tui có máu M, thích sự đau khổ</del></li>
</ol>
<h3>Những công nghệ tui dùng để làm blog</h3>
<p><strong>Frontend:</strong> Vue (Nuxt)<br>
Lý do dùng Vue đơn giản là vì nó đơn giản 🙂 còn tại sao dùng kèm Nuxt thì là vì bản thân Vue là client-side rendering, mà tui lại muốn có thêm server side rendering để tối ưu SEO tốt hơn, xịn xò hơn.</p>
<p><strong>Backend:</strong> Go<br>
Ban đầu tui tính dùng NodeJS vì deploy chung với Nuxt sẽ dễ hơn, nhưng mà sau nhiều năm xương máu code NodeJS thì tui đã nhận ra mỗi lần code xong, codebase sẽ rất là gớm và dễ lỗi vì Javascript không strongly-typed. Thật ra tui biết codebase gớm một phần là do bản thân gà, với cả nếu dùng chung với Typescript cũng khắc phục được chuyện strongly-typed, nhưng dù sao thì tui cũng đã có kinh nghiệm với Go, từng được sờ vào dự án Go thực tế rồi, với tui cũng tính đầu tư làm blog này lâu dài nên lỡ xài TS mà cũng gớm như thằng JS thì hơi toang 🙂.</p>
<p><strong>Database:</strong> MySQL<br>
Thằng này thì khỏi bình luận nhé, thuận mắt thì xài thôi 🙂 Vả lại biết mỗi thằng này với MongoDB, mà MongoDB tui dùng thấy không linh hoạt được, nên thôi dùng MySQL cho lành.</p>
<p>Ngoài ra thì tui còn dùng Docker để deploy lên Cloud Run của gu gồ, database cũng dùng của gu gồ nốt. Về phía client thì tui dùng Katex để render Latex, nghe bảo thằng này nhanh hơn Mathjax nên dùng thôi :))</p>
<h3>Định hướng cho blog</h3>
<p>Như tui cũng có nói, nội dung chủ yếu của blog sẽ là toán + tin, và tui cũng tính sẽ đưa một số project của mình lên nữa, làm như là một portfolio luôn. Hy vọng mọi người sẽ ủng hộ nhiệt tình &#x1f622;.</p>
<h3>Credit cho tiền bối</h3>
<p>Một số chức năng và cách tui thiết kế bố cục bài đăng cho blog được lấy cảm hứng từ <a href="https://thefullsnack.com" target="_blank"><a href="https://thefullsnack.com">https://thefullsnack.com</a></a> (có credit rồi nên mọi người đừng chửi tui ăn cắp ý tưởng nhé &#x1f622;). Đọc blog của anh này cũng là một trong những lý do mà tui quyết định bắt tay vào làm blog, quả blog anh làm đơn giản nhìn ghiền thiệt sự. Hiện thì ảnh đang là kĩ sư &ldquo;mặt tiền&rdquo; ở Silicon (nói chung là gia thế xịn nghen), chủ đề anh viết độc lạ hơn nhiều so với đa số blog IT ngoài kia nên là khuyến khích mọi người ngó qua nhà ảnh thử :)) Bạn có thể tham khảo thêm một số blog hay ho khác <a href="/posts/resources">ở đây</a>.</p>
]]></content:encoded>
      <author>ND Dang Khoa</author>
      <guid>https://balldk.github.io/posts/about</guid>
      <pubDate>Mon, 30 Aug 2021 20:30:05 +0700</pubDate>
    </item>
  </channel>
</rss>